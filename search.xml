<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JavaEE选修课-Ⅰ</title>
    <url>/2020/03/09/JavaEE%E9%80%89%E4%BF%AE%E8%AF%BE-%E2%85%A0/</url>
    <content><![CDATA[<a id="more"></a>

<h1 id="工具准备"><a href="#工具准备" class="headerlink" title="工具准备"></a>工具准备</h1><ul>
<li>JDK：目前已更新到13，使用8以上即可</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode594-643</title>
    <url>/2020/03/09/leetcode594-643/</url>
    <content><![CDATA[<h1 id="LeetCode-探索：发散你的思维"><a href="#LeetCode-探索：发散你的思维" class="headerlink" title="LeetCode 探索：发散你的思维"></a>LeetCode 探索：发散你的思维</h1><a id="more"></a>]]></content>
  </entry>
  <entry>
    <title>leetcode557-590</title>
    <url>/2020/03/07/leetcode557-590/</url>
    <content><![CDATA[<h1 id="LeetCode-探索：发散你的思维"><a href="#LeetCode-探索：发散你的思维" class="headerlink" title="LeetCode 探索：发散你的思维"></a>LeetCode 探索：发散你的思维</h1><a id="more"></a>

<h2 id="557-反转字符串中的单词-III"><a href="#557-反转字符串中的单词-III" class="headerlink" title="[557] 反转字符串中的单词 III"></a>[557] 反转字符串中的单词 III</h2><p><strong>给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。</strong></p>
<blockquote>
<p>解题思路：找到非空格字符和空格字符的位置</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @lc app=leetcode.cn id=557 lang=cpp</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [557] 反转字符串中的单词 III</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc code=start</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseWords</span><span class="params">(<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> front = s.find_first_not_of(<span class="string">' '</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> behind = s.find_first_of(<span class="string">' '</span>, front);</span><br><span class="line">        <span class="keyword">while</span> (front != <span class="built_in">string</span>::npos &amp;&amp; behind != <span class="built_in">string</span>::npos)</span><br><span class="line">        &#123;</span><br><span class="line">            reverse(s.begin() + front, s.begin() + behind);</span><br><span class="line">            front = s.find_first_not_of(<span class="string">' '</span>, behind);</span><br><span class="line">            behind = s.find_first_of(<span class="string">' '</span>, front);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (behind == <span class="built_in">string</span>::npos)</span><br><span class="line">            reverse(s.begin() + front, s.end());</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// @lc code=end</span></span><br></pre></td></tr></table></figure>

<h2 id="559-N叉树的最大深度"><a href="#559-N叉树的最大深度" class="headerlink" title="[559] N叉树的最大深度"></a>[559] N叉树的最大深度</h2><p><strong>给定一个 N 叉树，找到其最大深度。</strong></p>
<p><strong>最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。</strong></p>
<blockquote>
<p>解题思路：根据二叉树的树高公式 1+depth(left)+depth(right) 即可推广出来。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @lc app=leetcode.cn id=559 lang=cpp</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [559] N叉树的最大深度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc code=start</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    vector&lt;Node*&gt; children;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, vector&lt;Node*&gt; _children) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        children = _children;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(Node *root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node *child : root-&gt;children)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> d = maxDepth(child);</span><br><span class="line">            <span class="keyword">if</span> (d &gt; depth)</span><br><span class="line">                depth = d;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// @lc code=end</span></span><br></pre></td></tr></table></figure>

<h2 id="561-数组拆分-I"><a href="#561-数组拆分-I" class="headerlink" title="[561] 数组拆分 I"></a>[561] 数组拆分 I</h2><p><strong>给定长度为 2n 的数组, 你的任务是将这些数分成 n 对, 例如 (a1, b1), (a2, b2), … , (an, bn) ，使得从1 到 n 的 min(ai, bi) 总和最大。</strong></p>
<blockquote>
<p>解题思路：先排序，然后取每一组的第一个即可</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @lc app=leetcode.cn id=561 lang=cpp</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [561] 数组拆分 I</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc code=start</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">arrayPairSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i += <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// @lc code=end</span></span><br></pre></td></tr></table></figure>

<h2 id="563-二叉树的坡度"><a href="#563-二叉树的坡度" class="headerlink" title="[563] 二叉树的坡度"></a>[563] 二叉树的坡度</h2><p><strong>给定一个二叉树，计算整个树的坡度。</strong></p>
<p><strong>一个树的节点的坡度定义即为，该节点左子树的结点之和和右子树结点之和的差的绝对值。空结点的的坡度是0。</strong></p>
<p><strong>整个树的坡度就是其所有节点的坡度之和。</strong></p>
<blockquote>
<p>解题思路：递归计算每一个节点的坡度，然后将其累加起来</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @lc app=leetcode.cn id=563 lang=cpp</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [563] 二叉树的坡度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc code=start</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> tilt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calculate</span><span class="params">(TreeNode *node)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> L = calculate(node-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> R = calculate(node-&gt;right);</span><br><span class="line">        tilt += <span class="built_in">abs</span>(L - R);</span><br><span class="line">        <span class="keyword">return</span> node-&gt;val + L + R;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findTilt</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        calculate(root);</span><br><span class="line">        <span class="keyword">return</span> tilt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// @lc code=end</span></span><br></pre></td></tr></table></figure>

<h2 id="566-重塑矩阵"><a href="#566-重塑矩阵" class="headerlink" title="[566] 重塑矩阵"></a>[566] 重塑矩阵</h2><p><strong>在MATLAB中，有一个非常有用的函数 reshape，它可以将一个矩阵重塑为另一个大小不同的新矩阵，但保留其原始数据。</strong></p>
<p><strong>给出一个由二维数组表示的矩阵，以及两个正整数r和c，分别表示想要的重构的矩阵的行数和列数。</strong></p>
<p><strong>重构后的矩阵需要将原始矩阵的所有元素以相同的行遍历顺序填充。</strong></p>
<p><strong>如果具有给定参数的reshape操作是可行且合理的，则输出新的重塑矩阵；否则，输出原始矩阵。</strong></p>
<blockquote>
<p>解题思路：先用一个数组将元素给储存起来，然后再进行重塑</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @lc app=leetcode.cn id=566 lang=cpp</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [566] 重塑矩阵</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc code=start</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">matrixReshape</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;nums, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = nums.size() * nums[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">if</span> (r * c != size)</span><br><span class="line">            <span class="keyword">return</span> nums;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; row : nums)</span><br><span class="line">            arr.insert(arr.end(), row.begin(), row.end());</span><br><span class="line">        nums.clear();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            nums.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(arr.begin() + (i * c), arr.begin() + ((i + <span class="number">1</span>) * c)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// @lc code=end</span></span><br></pre></td></tr></table></figure>

<h2 id="572-另一个树的子树"><a href="#572-另一个树的子树" class="headerlink" title="[572] 另一个树的子树"></a>[572] 另一个树的子树</h2><p><strong>给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树。s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。</strong></p>
<blockquote>
<p>解题思路：先编写一个 equals(s, t) 函数用于递归判断以当前节点为根节点的二叉树是否相等，然后再遍历 s 的每一个节点即可。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @lc app=leetcode.cn id=572 lang=cpp</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [572] 另一个树的子树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc code=start</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">equals</span><span class="params">(TreeNode *s, TreeNode *t)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">NULL</span> &amp;&amp; t == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">NULL</span> || t == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> s-&gt;val == t-&gt;val &amp;&amp; equals(s-&gt;left, t-&gt;left) &amp;&amp; equals(s-&gt;right, t-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubtree</span><span class="params">(TreeNode *s, TreeNode *t)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s != <span class="literal">NULL</span> &amp;&amp; (equals(s, t) || isSubtree(s-&gt;left, t) || isSubtree(s-&gt;right, t));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// @lc code=end</span></span><br></pre></td></tr></table></figure>

<h2 id="575-分糖果"><a href="#575-分糖果" class="headerlink" title="[575] 分糖果"></a>[575] 分糖果</h2><p><strong>给定一个偶数长度的数组，其中不同的数字代表着不同种类的糖果，每一个数字代表一个糖果。你需要把这些糖果平均分给一个弟弟和一个妹妹。返回妹妹可以获得的最大糖果的种类数。</strong></p>
<blockquote>
<p>解题思路：由题意可知，妹妹最多可以分到的糖果不超过 n / 2 ，当种类数小于 n / 2 时，则将所有种类各分一个给妹妹即可。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @lc app=leetcode.cn id=575 lang=cpp</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [575] 分糖果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc code=start</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">distributeCandies</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;candies)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; category;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : candies)</span><br><span class="line">            category.insert(n);</span><br><span class="line">        <span class="keyword">return</span> min(candies.size() / <span class="number">2</span>, category.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// @lc code=end</span></span><br></pre></td></tr></table></figure>

<h2 id="581-最短无序连续子数组"><a href="#581-最短无序连续子数组" class="headerlink" title="[581] 最短无序连续子数组"></a>[581] 最短无序连续子数组</h2><p><strong>给定一个整数数组，你需要寻找一个连续的子数组，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。</strong></p>
<p><strong>你找到的子数组应是最短的，请输出它的长度。</strong></p>
<blockquote>
<p>解题思路：拷贝该数组并排序，然后顺序查找第一个不同的元素并记录其下标即可。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @lc app=leetcode.cn id=581 lang=cpp</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [581] 最短无序连续子数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc code=start</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findUnsortedSubarray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">temp</span><span class="params">(nums.begin(), nums.end())</span></span>;</span><br><span class="line">        sort(temp.begin(), temp.end());</span><br><span class="line">        <span class="keyword">int</span> front = <span class="number">0</span>, back = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp[i] != nums[i])</span><br><span class="line">            &#123;</span><br><span class="line">                front = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp[i] != nums[i])</span><br><span class="line">            &#123;</span><br><span class="line">                back = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> back == front ? <span class="number">0</span> : back - front + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// @lc code=end</span></span><br></pre></td></tr></table></figure>

<h2 id="589-N叉树的前序遍历"><a href="#589-N叉树的前序遍历" class="headerlink" title="[589] N叉树的前序遍历"></a>[589] N叉树的前序遍历</h2><p><strong>给定一个 N 叉树，返回其节点值的前序遍历。</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @lc app=leetcode.cn id=589 lang=cpp</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [589] N叉树的前序遍历</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc code=start</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    vector&lt;Node*&gt; children;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, vector&lt;Node*&gt; _children) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        children = _children;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归算法</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">preorder</span><span class="params">(Node *root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(root-&gt;val);</span><br><span class="line">            <span class="keyword">for</span> (Node *child : root-&gt;children)</span><br><span class="line">                preorder(child);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//迭代算法</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">preorder</span><span class="params">(Node *root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">stack</span>&lt;Node *&gt; nodes;</span><br><span class="line">        nodes.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!nodes.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            Node *node = nodes.top();</span><br><span class="line">            nodes.pop();</span><br><span class="line">            res.push_back(node-&gt;val);</span><br><span class="line">            <span class="built_in">vector</span>&lt;Node *&gt; temp = node-&gt;children;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = temp.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (temp[i] != <span class="literal">NULL</span>)</span><br><span class="line">                    nodes.push(temp[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// @lc code=end</span></span><br></pre></td></tr></table></figure>

<h2 id="590-N叉树的后序遍历"><a href="#590-N叉树的后序遍历" class="headerlink" title="[590] N叉树的后序遍历"></a>[590] N叉树的后序遍历</h2><p><strong>给定一个 N 叉树，返回其节点值的后序遍历。</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @lc app=leetcode.cn id=590 lang=cpp</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [590] N叉树的后序遍历</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc code=start</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    vector&lt;Node*&gt; children;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, vector&lt;Node*&gt; _children) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        children = _children;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归方法</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">postorder</span><span class="params">(Node *root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">for</span> (Node *child : root-&gt;children)</span><br><span class="line">            postorder(child);</span><br><span class="line">        res.push_back(root-&gt;val);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//迭代方法</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">postorder</span><span class="params">(Node *root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">stack</span>&lt;Node *&gt; nodes;</span><br><span class="line">        nodes.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!nodes.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            Node *node = nodes.top();</span><br><span class="line">            nodes.pop();</span><br><span class="line">            res.insert(res.begin(), node-&gt;val);</span><br><span class="line">            <span class="keyword">for</span> (Node *child : node-&gt;children)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (child != <span class="literal">NULL</span>)</span><br><span class="line">                    nodes.push(child);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// @lc code=end</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode507-551</title>
    <url>/2020/03/06/leetcode507-551/</url>
    <content><![CDATA[<h1 id="LeetCode-探索：发散你的思维"><a href="#LeetCode-探索：发散你的思维" class="headerlink" title="LeetCode 探索：发散你的思维"></a>LeetCode 探索：发散你的思维</h1><a id="more"></a>

<h2 id="507-完美数"><a href="#507-完美数" class="headerlink" title="[507] 完美数"></a>[507] 完美数</h2><p><strong>对于一个 正整数，如果它和除了它自身以外的所有正因子之和相等，我们称它为“完美数”。</strong></p>
<p><strong>给定一个 整数 n， 如果他是完美数，返回 True，否则返回 False</strong></p>
<blockquote>
<p>解题思路：在 [1, sqrt(num)] 内从左往右迭代，依次求出num的因子，当 num % i == 0 时，num 的因子有两个：i 和 num / i，但注意当 i * i == num 时的情形，此时因子只有一个。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @lc app=leetcode.cn id=507 lang=cpp</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [507] 完美数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc code=start</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkPerfectNumber</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i * i &lt;= num; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (num % i == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                n += i;</span><br><span class="line">                <span class="keyword">if</span> (i * i != num)</span><br><span class="line">                    n += num / i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num == n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">// @lc code=end</span></span><br></pre></td></tr></table></figure>

<h2 id="509-斐波那契数"><a href="#509-斐波那契数" class="headerlink" title="[509] 斐波那契数"></a>[509] 斐波那契数</h2><p><strong>斐波那契数，通常用 F(n) 表示，形成的序列称为斐波那契数列。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。给定N，计算F(N)。</strong></p>
<blockquote>
<p>解题思路：递归</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @lc app=leetcode.cn id=509 lang=cpp</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [509] 斐波那契数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc code=start</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (N == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (N == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> fib(N - <span class="number">1</span>) + fib(N - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">// @lc code=end</span></span><br></pre></td></tr></table></figure>

<h2 id="520-检测大写字母"><a href="#520-检测大写字母" class="headerlink" title="[520] 检测大写字母"></a>[520] 检测大写字母</h2><p><strong>给定一个单词，你需要判断单词的大写使用是否正确。</strong></p>
<p><strong>我们定义，在以下情况时，单词的大写用法是正确的：</strong></p>
<ul>
<li><strong>全部字母都是大写，比如”USA”。</strong></li>
<li><strong>单词中所有字母都不是大写，比如”leetcode”。</strong></li>
<li><strong>如果单词不只含有一个字母，只有首字母大写， 比如 “Google”。</strong></li>
<li><strong>否则，我们定义这个单词没有正确使用大写字母。</strong></li>
</ul>
<blockquote>
<p>解题思路：只需对大写字母进行计数即可</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @lc app=leetcode.cn id=520 lang=cpp</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [520] 检测大写字母</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc code=start</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">detectCapitalUse</span><span class="params">(<span class="built_in">string</span> word)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> up = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : word)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isupper</span>(c))</span><br><span class="line">                up++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                low++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> up == <span class="number">0</span> || low == <span class="number">0</span> || (up == <span class="number">1</span> &amp;&amp; <span class="built_in">isupper</span>(word[<span class="number">0</span>]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">// @lc code=end</span></span><br></pre></td></tr></table></figure>

<h2 id="521-最长特殊序列-Ⅰ"><a href="#521-最长特殊序列-Ⅰ" class="headerlink" title="[521] 最长特殊序列 Ⅰ"></a>[521] 最长特殊序列 Ⅰ</h2><p><strong>给定两个字符串，你需要从这两个字符串中找出最长的特殊序列。最长特殊序列定义如下：该序列为某字符串独有的最长子序列（即不能是其他字符串的子序列）。</strong></p>
<p><strong>子序列可以通过删去字符串中的某些字符实现，但不能改变剩余字符的相对顺序。空序列为所有字符串的子序列，任何字符串为其自身的子序列。</strong></p>
<p><strong>输入为两个字符串，输出最长特殊序列的长度。如果不存在，则返回 -1。</strong></p>
<blockquote>
<p>解题思路：当a和b相等时，此时不存在最长特殊序列，返回-1；当a和b的长度不相等时，较长字符串不可能是较短字符串的子串，因此最长特殊序列则为较长字符串本身。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @lc app=leetcode.cn id=521 lang=cpp</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [521] 最长特殊序列 Ⅰ</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc code=start</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findLUSlength</span><span class="params">(<span class="built_in">string</span> a, <span class="built_in">string</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a == b)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> max(a.length(), b.length());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">// @lc code=end</span></span><br></pre></td></tr></table></figure>

<h2 id="530-二叉搜索树的最小绝对差"><a href="#530-二叉搜索树的最小绝对差" class="headerlink" title="[530] 二叉搜索树的最小绝对差"></a>[530] 二叉搜索树的最小绝对差</h2><p><strong>给定一个所有节点为非负值的二叉搜索树，求树中任意两节点的差的绝对值的最小值。</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @lc app=leetcode.cn id=530 lang=cpp</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [530] 二叉搜索树的最小绝对差</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc code=start</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val; </span></span><br><span class="line"><span class="comment"> *     TreeNode *left; </span></span><br><span class="line"><span class="comment"> *     TreeNode *right; </span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;; </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">travel</span><span class="params">(TreeNode *root, <span class="keyword">int</span> &amp;pre, <span class="keyword">int</span> &amp;diff)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        travel(root-&gt;left, pre, diff);</span><br><span class="line">        <span class="keyword">if</span> (pre &gt;= <span class="number">0</span>)</span><br><span class="line">            diff = min(diff, root-&gt;val - pre);</span><br><span class="line">        pre = root-&gt;val;</span><br><span class="line">        travel(root-&gt;right, pre, diff);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMinimumDifference</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> diff = INT32_MAX;</span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">-1</span>;</span><br><span class="line">        travel(root, pre, diff);</span><br><span class="line">        <span class="keyword">return</span> diff;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">// @lc code=end</span></span><br></pre></td></tr></table></figure>

<h2 id="532-数组中的K-diff数对"><a href="#532-数组中的K-diff数对" class="headerlink" title="[532] 数组中的K-diff数对"></a>[532] 数组中的K-diff数对</h2><p><strong>给定一个整数数组和一个整数 k, 你需要在数组里找到不同的 k-diff 数对。这里将 k-diff 数对定义为一个整数对 (i, j), 其中 i 和 j 都是数组中的数字，且两数之差的绝对值是 k.</strong></p>
<blockquote>
<p>解题思路：利用set的元素唯一性的特性</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @lc app=leetcode.cn id=532 lang=cpp</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [532] 数组中的K-diff数对</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc code=start</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findPairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.size() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">set</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; sets;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size() - <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.size(); j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + k == nums[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    sets.insert(&#123;nums[i], nums[j]&#125;);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sets.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">// @lc code=end</span></span><br></pre></td></tr></table></figure>

<h2 id="538-把二叉搜索树转换为累加树"><a href="#538-把二叉搜索树转换为累加树" class="headerlink" title="[538] 把二叉搜索树转换为累加树"></a>[538] 把二叉搜索树转换为累加树</h2><p><strong>给定一个二叉搜索树（Binary Search Tree），把它转换成为累加树（Greater Tree)，使得每个节点的值是原来的节点值加上所有大于它的节点值之和。</strong></p>
<blockquote>
<p>解题思路：由BST的特性可知，右子树的值大于根节点的值，因此需要用到反序中序遍历，即先遍历右子树，后遍历根节点，最后遍历左子树，从右边开始累加起来，最后回溯的时候赋值。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @lc app=leetcode.cn id=538 lang=cpp</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [538] 把二叉搜索树转换为累加树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc code=start</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val; </span></span><br><span class="line"><span class="comment"> *     TreeNode *left; </span></span><br><span class="line"><span class="comment"> *     TreeNode *right; </span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;; </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归方法：反序中序遍历，即先遍历右子树，再遍历根节点，最后遍历左子树</span></span><br><span class="line">    <span class="function">TreeNode *<span class="title">convertBST</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        convertBST(root-&gt;right);</span><br><span class="line">        sum += root-&gt;val;</span><br><span class="line">        root-&gt;val = sum;</span><br><span class="line">        convertBST(root-&gt;left);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//迭代方法：使用栈来对树进行回溯</span></span><br><span class="line">    <span class="function">TreeNode *<span class="title">convertBST</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode *&gt; st;</span><br><span class="line">        TreeNode *node = root;</span><br><span class="line">        <span class="keyword">while</span> (!st.empty() || node != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (node != <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                st.push(node);</span><br><span class="line">                node = node-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            node = st.top();</span><br><span class="line">            st.pop();</span><br><span class="line">            sum += node-&gt;val;</span><br><span class="line">            node-&gt;val = sum;</span><br><span class="line">            node = node-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">// @lc code=end</span></span><br></pre></td></tr></table></figure>

<h2 id="541-反转字符串-II"><a href="#541-反转字符串-II" class="headerlink" title="[541] 反转字符串 II"></a>[541] 反转字符串 II</h2><p><strong>给定一个字符串和一个整数 k，你需要对从字符串开头算起的每个 2k 个字符的前k个字符进行反转。如果剩余少于 k 个字符，则将剩余的所有全部反转。如果有小于 2k 但大于或等于 k 个字符，则反转前 k 个字符，并将剩余的字符保持原样。</strong></p>
<blockquote>
<p>解题思路：只需要记录需要反转的子串的下标即可</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @lc app=leetcode.cn id=541 lang=cpp</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [541] 反转字符串 II</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc code=start</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseStr</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i * <span class="number">2</span> * k &lt; s.length(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> start = i * <span class="number">2</span> * k;</span><br><span class="line">            <span class="keyword">int</span> temp = (i + <span class="number">1</span>) * <span class="number">2</span> * k;</span><br><span class="line">            <span class="keyword">int</span> end = (temp + start) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (end &gt; s.length())</span><br><span class="line">                end = s.length();</span><br><span class="line">            reverse(s.begin() + start, s.begin() + end);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">// @lc code=end</span></span><br></pre></td></tr></table></figure>

<h2 id="543-二叉树的直径"><a href="#543-二叉树的直径" class="headerlink" title="[543] 二叉树的直径"></a>[543] 二叉树的直径</h2><p><strong>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过根结点。</strong></p>
<blockquote>
<p>解题思路：任意一条路径可以被写成两个箭头（不同方向），每个箭头代表一条从某些点向下遍历到孩子节点的路径。假设我们知道对于每个节点最长箭头距离分别为 L, R，那么最优路径经过 L + R + 1 个节点。<br>按照常用方法计算一个节点的深度：max(depth of node.left, depth of node.right) + 1。在计算的同时，经过这个节点的路径长度为 1 + (depth of node.left) + (depth of node.right) 。搜索每个节点并记录这些路径经过的点数最大值count，期望长度是 count - 1。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @lc app=leetcode.cn id=543 lang=cpp</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [543] 二叉树的直径</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc code=start</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val; </span></span><br><span class="line"><span class="comment"> *     TreeNode *left; </span></span><br><span class="line"><span class="comment"> *     TreeNode *right; </span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;; </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> dia = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">travel</span><span class="params">(TreeNode *node)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> L = travel(node-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> R = travel(node-&gt;right);</span><br><span class="line">        dia = max(dia, L + R + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + max(L, R);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        travel(root);</span><br><span class="line">        <span class="keyword">return</span> dia - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">// @lc code=end</span></span><br></pre></td></tr></table></figure>

<h2 id="551-学生出勤记录-I"><a href="#551-学生出勤记录-I" class="headerlink" title="[551] 学生出勤记录 I"></a>[551] 学生出勤记录 I</h2><p><strong>给定一个字符串来代表一个学生的出勤记录，这个记录仅包含以下三个字符：</strong></p>
<ul>
<li><strong>‘A’ : Absent，缺勤</strong></li>
<li><strong>‘L’ : Late，迟到</strong></li>
<li><strong>‘P’ : Present，到场</strong></li>
<li><strong>如果一个学生的出勤记录中不超过一个’A’(缺勤)并且不超过两个连续的’L’(迟到), 那么这个学生会被奖赏。</strong></li>
</ul>
<p><strong>你需要根据这个学生的出勤记录判断他是否会被奖赏。</strong></p>
<blockquote>
<p>解题思路：首先记录A的数量，其次记录连续的L的数量，当遇到连续的L但其数量小于等于2时，将其置为0重新计数</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @lc app=leetcode.cn id=551 lang=cpp</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [551] 学生出勤记录 I</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc code=start</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkRecord</span><span class="params">(<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> A = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> L = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">'A'</span>)</span><br><span class="line">                A++;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">'L'</span>)</span><br><span class="line">                L++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (L &lt;= <span class="number">2</span>)</span><br><span class="line">                L = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> A &lt;= <span class="number">1</span> &amp;&amp; L &lt;= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">// @lc code=end</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>MachineVision-1</title>
    <url>/2020/03/05/MachineVision-1/</url>
    <content><![CDATA[<p><strong>这是摘要</strong>：等我有空再写！！！</p>
<a id="more"></a>

<h1 id="第一章-视觉计算中的数据"><a href="#第一章-视觉计算中的数据" class="headerlink" title="第一章 视觉计算中的数据"></a>第一章 视觉计算中的数据</h1><h2 id="数据可视化"><a href="#数据可视化" class="headerlink" title="数据可视化"></a>数据可视化</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul>
<li><p>数据空间：由n维属性和m个元素组成的数据集所构成的多维信息空间</p>
</li>
<li><p>数据开发：指利用算法和工具对数据进行定量的推演和计算</p>
</li>
<li><p>数据分析：指对多维数据进行切片、块、旋转等动作剖析数据，从而能多角度多方面观察数据</p>
</li>
<li><p>数据可视化：指将大型数据集中的数据以图像形式表示，并利用数据分析和开发工具发现其中未知信息的处理过程</p>
</li>
<li><p>可视化算法与技术方法</p>
</li>
<li><p>立体可视化</p>
</li>
<li><p>信息可视化</p>
</li>
<li><p>多分辨率方法</p>
</li>
<li><p>建模技术方法</p>
</li>
<li><p>交互技术方法与体系架构</p>
</li>
</ul>
<h2 id="数据离散化"><a href="#数据离散化" class="headerlink" title="数据离散化"></a>数据离散化</h2><h3 id="采样"><a href="#采样" class="headerlink" title="采样"></a>采样</h3><ul>
<li>均匀采样：指将一副二维连续图像 <strong>(f,x,y)</strong> 的连续二位图像平面在x方向和y方向上进行等间距划分。从而将该二维图像平面划分为 <strong>M * N</strong> 个网络，并且各网络中心点的位置与一堆是证书表示的笛卡尔坐标 <strong>(i,j)</strong> 相对于的过程。</li>
</ul>
<h3 id="量化"><a href="#量化" class="headerlink" title="量化"></a>量化</h3><h2 id="数据表示"><a href="#数据表示" class="headerlink" title="数据表示"></a>数据表示</h2><h3 id="时域（空域）表示"><a href="#时域（空域）表示" class="headerlink" title="时域（空域）表示"></a>时域（空域）表示</h3><p><strong>普通音频数据：</strong>$A(t)=sin(t)+\frac{1}{2}sin(2t)$</p>
<h3 id="频域表示"><a href="#频域表示" class="headerlink" title="频域表示"></a>频域表示</h3><p><strong>频域：将信号堪称一组更加基础的信号（如正余弦波）的混合（如线性组合）</strong></p>
<p><strong>信号可以表示为基础信号组合成原始信号的组合系数</strong></p>
<p>$$c(t) = \sum_{i=1}^{\infty} a_icos(f_i+p_i)$$</p>
<h3 id="几何数据"><a href="#几何数据" class="headerlink" title="几何数据"></a>几何数据</h3><ul>
<li>显示表示</li>
<li>隐式表示</li>
<li>参数化表示</li>
</ul>
<p>在几何数据的离散化表示中，不同于解析表示。一个几何实体用一组其他几何实体的集合表示。（如一个二位正方形可以定义为二位空间中一组线的表示）</p>
<p>构成网格的实体（如线、三角形或四边形）我们称为<strong>基元</strong></p>
<h2 id="噪声"><a href="#噪声" class="headerlink" title="噪声"></a>噪声</h2><h3 id="随机噪声"><a href="#随机噪声" class="headerlink" title="随机噪声"></a>随机噪声</h3><p><strong>低通滤波</strong>是去除数据中的随机噪声的一种常用技术。</p>
<h3 id="椒盐噪声"><a href="#椒盐噪声" class="headerlink" title="椒盐噪声"></a>椒盐噪声</h3><p><strong>中值滤波器</strong>或者其他<strong>顺序统计滤波器能够较好地处理这样的异常值</strong></p>
<p>采用<strong>陷波滤波器</strong>去除频域噪声</p>
]]></content>
      <categories>
        <category>机器视觉</category>
      </categories>
      <tags>
        <tag>机器视觉</tag>
      </tags>
  </entry>
  <entry>
    <title>Core-Java-Fundamentals-ⅩⅣ</title>
    <url>/2020/03/04/Core-Java-Fundamentals-%E2%85%A9%E2%85%A3/</url>
    <content><![CDATA[<p><strong>这是摘要</strong>：等我有空再写！！！</p>
<a id="more"></a>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Core-Java-Fundamentals-Ⅸ</title>
    <url>/2020/03/04/Core-Java-Fundamentals-%E2%85%A8/</url>
    <content><![CDATA[<p><strong>这是摘要</strong>：等我有空再写！！！</p>
<a id="more"></a>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Core-Java-Fundamentals-Ⅷ</title>
    <url>/2020/03/04/Core-Java-Fundamentals-%E2%85%A7/</url>
    <content><![CDATA[<p><strong>这是摘要</strong>：等我有空再写！！！</p>
<a id="more"></a>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Core-Java-Fundamentals-Ⅶ</title>
    <url>/2020/03/04/Core-Java-Fundamentals-%E2%85%A6/</url>
    <content><![CDATA[<p><strong>这是摘要</strong>：等我有空再写！！！</p>
<a id="more"></a>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Core-Java-Fundamentals-Ⅵ</title>
    <url>/2020/03/04/Core-Java-Fundamentals-%E2%85%A5/</url>
    <content><![CDATA[<p><strong>这是摘要</strong>：等我有空再写！！！</p>
<a id="more"></a>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Core-Java-Fundamentals-Ⅴ</title>
    <url>/2020/03/04/Core-Java-Fundamentals-%E2%85%A4/</url>
    <content><![CDATA[<p><strong>这是摘要</strong>：等我有空再写！！！</p>
<a id="more"></a>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Core-Java-Fundamentals-Ⅳ</title>
    <url>/2020/03/04/Core-Java-Fundamentals-%E2%85%A3/</url>
    <content><![CDATA[<a id="more"></a>

<h1 id="第4章-对象与类"><a href="#第4章-对象与类" class="headerlink" title="第4章 对象与类"></a>第4章 对象与类</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Core-Java-Fundamentals-Ⅲ</title>
    <url>/2020/03/04/Core-Java-Fundamentals-%E2%85%A2/</url>
    <content><![CDATA[<a id="more"></a>

<h1 id="第-3章-Java-的基本程序设计结构"><a href="#第-3章-Java-的基本程序设计结构" class="headerlink" title="第 3章 Java 的基本程序设计结构"></a>第 3章 Java 的基本程序设计结构</h1><hr>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">字节数</th>
</tr>
</thead>
<tbody><tr>
<td align="center">int</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center">short</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">long</td>
<td align="center">8</td>
</tr>
<tr>
<td align="center">byte</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">float</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center">double</td>
<td align="center">8</td>
</tr>
<tr>
<td align="center">char</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">boolean</td>
<td align="center">单个boolean变量是4字节<br>boolean数组的每一个值是1字节</td>
</tr>
</tbody></table>
<h4 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h4><p>在Java中，整型的范围与运行Java代码的机器无关。而C和C++则需要针对不同的处理器选择最为高效的整型。</p>
<p>长整型数值有一个后缀L或l（如9000000000000L）。十六进制数值有一个前缀0x或0X（如0xCAFE）。八进制数值有一个前缀0（如010对应八进制中的8）。</p>
<p>从Java7开始，加上前缀0b或0B就可以写二进制数（如0b1001对应二进制中的9）。同时还可以为数字字面量添加下划线（如0b111_0110_0100_0000_1001_0111），这些下划线只是为了让人们更易读，Java编译器会除去这些下划线。</p>
<h4 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h4><p><strong>浮点类型用于表示有小数部分的数值。</strong>double类型表示的数值精度是float类型的两倍，绝大部分的程序都使用double类型。</p>
<p>float类型的数值有一个后缀F或f，没有后缀F或f的浮点数值默认为double类型。当然，也可以在浮点数值后添加后缀D或d。</p>
<h4 id="char类型"><a href="#char类型" class="headerlink" title="char类型"></a>char类型</h4><p>char类型用于表示单个字符。有些Unicode字符可以用一个char值描述。</p>
<h4 id="boolean类型"><a href="#boolean类型" class="headerlink" title="boolean类型"></a>boolean类型</h4><p>boolean（布尔）类型有两个值：<strong>false</strong> 和 <strong>true</strong>，用来判定逻辑条件。整型值和布尔值之间不能进行互相转换。</p>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>变量名必须是一个以字符开头并由字符或数字构成的序列。其中，字符包括：’A’ ~ ‘Z’、’a’ ~ ‘z’、’_’、’$’或在某种语言中表示字母的任何Unicode字符。</p>
<h4 id="变量初始化"><a href="#变量初始化" class="headerlink" title="变量初始化"></a>变量初始化</h4><p>声明一个变量后，必须使用赋值语句对变量进行显式初始化，不要使用未初始化的变量。</p>
<h4 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h4><p>在Java中，利用关键字 <strong>final</strong> 指示常量。关键字 <strong>final</strong> 表示这个变量只能被赋值一次。一旦被赋值之后，就不能够再更改了。习惯上，常量名使用全大写。</p>
<p>在 Java 中，经常希望某个常量可以在一个类中的多个方法中使用，通常将这些常量称为类常量。可以使用关键字 <strong>static final</strong> 设置一个类常量。</p>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>在 Java 中，使用算术运算符 +、-、 *、/ 表示加、减、 乘、除运算。 当参与 / 运算的两个操作数都是整数时， 表示整数除法；否则， 表示浮点除法。 整数的求余操作（有时称为取模) 用 ％ 表示。例如，15/2=7，15%2=1 , 15.0/2=7.50。</p>
<p>需要注意， 整数被 0 除将会产生一个异常， 而浮点数被 0 除将会得到无穷大或 NaN 结果。</p>
<h4 id="数学函数与常量"><a href="#数学函数与常量" class="headerlink" title="数学函数与常量"></a>数学函数与常量</h4><p>在Math类中，包含了各种各样的数学函数和数学常量。</p>
<h4 id="数值类型之间的转换"><a href="#数值类型之间的转换" class="headerlink" title="数值类型之间的转换"></a>数值类型之间的转换</h4><p><img src="F:%5CBlog%5Cblog%5Csource%5Cimages%5C0001.PNG" alt="1"></p>
<p><strong>数值类型转换的规则</strong></p>
<ul>
<li>如果两个操作数中有一个是 double 类型，另一个操作数就会转换为 double 类型。</li>
<li>否则，如果其中一个操作数是 float 类型，另一个操作数将会转换为 float 类型。</li>
<li>否则，如果其中一个操作数是 long 类型，另一个操作数将会转换为 long 类型。</li>
<li>否则，两个操作数都将被转换为 int 类型。</li>
</ul>
<h4 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h4><p>在上一小节中看到，在必要的时候，int 类型的值将会自动地转换为 double 类型。但另一方面，有时也需要将 double 转换成int。在 Java 中，允许进行这种数值之间的类型转换。当然，有可能会丢失一些信息。在这种情况下，需要通过强制类型转换（cast）实现这个操作。强制类型转换的语法格式是在圆括号中给出想要转换的目标类型，后面紧跟待转换的变量名。</p>
<h4 id="结合赋值和运算符"><a href="#结合赋值和运算符" class="headerlink" title="结合赋值和运算符"></a>结合赋值和运算符</h4><p>可以在赋值中使用二元运算符。如+=、-=、%=、^=等等。</p>
<h4 id="自增与自减运算符"><a href="#自增与自减运算符" class="headerlink" title="自增与自减运算符"></a>自增与自减运算符</h4><p>后缀和前缀形式都会使变量值加 1 或减 1。但用在表达式中时，二者就有区别了。前缀形式会先完成加 1；而后缀形式会使用变量原来的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> m = <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">2</span> * ++m;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">2</span> * n++;</span><br></pre></td></tr></table></figure>

<h4 id="关系和-boolean-运算符"><a href="#关系和-boolean-运算符" class="headerlink" title="关系和 boolean 运算符"></a>关系和 boolean 运算符</h4><p>关系运算符有==、!=、&gt;、&lt;、&gt;=、&lt;=、&amp;&amp;、||等</p>
<p>Java支持三元操作符 <strong>? :</strong> ，遵循以下格式</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">condition ? expressioni : expression</span><br></pre></td></tr></table></figure>

<h4 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h4><p>处理整型类型时，可以直接对组成整型数值的各个位完成操作。这意味着可以使用掩码技术得到整数中的各个位。位运算符包括：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&amp;(<span class="string">"and"</span>)  |(<span class="string">"or"</span>)  ^(<span class="string">"xor"</span>)  ~(<span class="string">"not"</span>)</span><br></pre></td></tr></table></figure>

<h4 id="括号与运算符级别"><a href="#括号与运算符级别" class="headerlink" title="括号与运算符级别"></a>括号与运算符级别</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a &amp;&amp; b || c <span class="comment">//从左到右</span></span><br></pre></td></tr></table></figure>

<p><img src="F:%5CBlog%5Cblog%5Csource%5Cimages%5C0002.PNG" alt="0002"></p>
<h4 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h4><p>枚举类型包括有限个命名的值。 例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> Size &#123;SMALL, MEDIUM, LARGE&#125; <span class="comment">//自定义枚举类型</span></span><br><span class="line"></span><br><span class="line">Size s = Size.MEDIUM <span class="comment">//声明枚举变量</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//Size类型的变量只能存储这个类型声明中给定的某个枚举值，或者null值，null表示这个变量没有设置任何值。</span></span><br></pre></td></tr></table></figure>

<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>从概念上讲， Java 字符串就是 Unicode 字符序列。Java 没有内置的字符串类型， 而是在标准 Java 类库中提供了一个预定义类，很自然地叫做 String。</p>
<h4 id="子串"><a href="#子串" class="headerlink" title="子串"></a>子串</h4><p>String 类的 substring 方法可以从一个较大的字符串提取出一个子串。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String greeting = <span class="string">"Hello"</span>;</span><br><span class="line">String s = greeting.substring(<span class="number">0</span>, <span class="number">3</span>); <span class="comment">//s = "Hel"</span></span><br></pre></td></tr></table></figure>

<h4 id="拼接"><a href="#拼接" class="headerlink" title="拼接"></a>拼接</h4><p>与绝大多数的程序设计语言一样，Java语言允许使用 + 号连接（拼接）两个字符串。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String expletive = <span class="string">"Expletive"</span>;</span><br><span class="line">String PC13 = <span class="string">"deleted"</span>;</span><br><span class="line">String message = expletive + PC13;</span><br></pre></td></tr></table></figure>

<p>当将一个字符串与一个非字符串的值进行拼接时，后者被转换成字符串（在第 5 章中可以看到，任何一个 Java 对象都可以转换成字符串）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> age = <span class="number">13</span>;</span><br><span class="line">String rating = <span class="string">"PC"</span> + age; <span class="comment">//rating = "PC13"</span></span><br></pre></td></tr></table></figure>

<p>如果需要把多个字符串放在一起， 用一个定界符分隔，可以使用静态 join 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String all = String.join(<span class="string">" / "</span>, <span class="string">"S"</span>, <span class="string">"M"</span>, <span class="string">"L"</span>, <span class="string">"XL"</span>);</span><br><span class="line"><span class="comment">// all is the string "S / H / L / XL"</span></span><br></pre></td></tr></table></figure>

<h4 id="不可变字符串"><a href="#不可变字符串" class="headerlink" title="不可变字符串"></a>不可变字符串</h4><p>String 类没有提供用于修改字符串的方法6 如果希望将 greeting 的内容修改为“ Help!”，不能直接地将 greeting 的最后两个位置的字符修改为‘ p ’ 和’ ! ‘。如何修改这个字符串呢？ 在 Java中实现这项操作非常容易。首先提取需要的字符， 然后再拼接上替换的字符串：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">greeting = greeting.substring(<span class="number">0</span>, <span class="number">3</span>) + <span class="string">"p!"</span>;</span><br><span class="line"><span class="comment">//上面这条语句将 greeting 当前值修改为“Help!”。</span></span><br></pre></td></tr></table></figure>

<p>由于不能修改 Java 字符串中的字符， 所以在 Java 文档中将 String 类对象称为<strong>不可变字符串</strong>， 如同数字3永远是数字3—样，字符串“ Hello” 永远包含字符 H、e、1、1 和 o 的代码单元序列， 而不能修改其中的任何一个字符。当然，可以修改字符串变量 greeting，让它引用另外一个字符串，这就如同可以将存放 3 的数值变量改成存放 4 一样。</p>
<p><strong>不可变字符串却有一个优点：编译器可以让字符串共享。</strong>为了弄清具体的工作方式，可以想象将各种字符串存放在公共的存储池中。字符串变量指向存储池中相应的位置。如果复制一个字符串量，原始字符串与复制的字符串共享相同的字符。</p>
<p>如果将 greeting 赋予另外一个值又会怎样呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">greeting = <span class="string">"Howdy"</span>;</span><br><span class="line"><span class="comment">//这样做会不会产生内存遗漏呢？毕竞，原始字符串放置在堆中。十分幸运，Java将自动地进行垃圾回收。如果一块内存不再使用了，系统最终会将其回收。</span></span><br></pre></td></tr></table></figure>

<h4 id="检测字符串是否相等"><a href="#检测字符串是否相等" class="headerlink" title="检测字符串是否相等"></a>检测字符串是否相等</h4><p>可以使用 equals 方法检测两个字符串是否相等。对于表达式： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">s.equals(t)</span><br><span class="line"><span class="comment">//如果字符串s与字符串t相等，则返回true;否则，返回false。需要注意，s与t可以是字符串变量， 也可以是字符串字面量。</span></span><br></pre></td></tr></table></figure>

<p>一定不要使用=运算符检测两个字符串是否相等！ 这个运算符只能够确定两个字串是否放置在同一个位置上。(即是否引用的是同一块内存区域)</p>
<h4 id="空船与null串"><a href="#空船与null串" class="headerlink" title="空船与null串"></a>空船与null串</h4><p>空串 “” 是长度为 0 的字符串。可以调用以下代码检查一个字符串是否为空：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (str.lengthQ = <span class="number">0</span>) </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (str.equals(<span class="string">""</span>))</span><br></pre></td></tr></table></figure>

<p>空串是一个 Java 对象，有自己的串长度（0）和内容（空）。不过，String 变量还可以存放一个特殊的值，名为 null, 这表示目前没有任何对象与该变量关联（关于 null 的更多信息请参见第 4 章)。要检查一个字符串是否为 null, 要使用以下条件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (str == <span class="keyword">null</span>)</span><br></pre></td></tr></table></figure>

<h4 id="构建字符串"><a href="#构建字符串" class="headerlink" title="构建字符串"></a>构建字符串</h4><p>有些时候， 需要由较短的字符串构建字符串， 例如， 按键或来自文件中的单词。采用字符串连接的方式达到此目的效率比较低。每次连接字符串， 都会构建一个新的 String 对象，既耗时， 又浪费空间。使用 StringBuildei•类就可以避免这个问题的发生。</p>
<p>如果需要用许多小段的字符串构建一个字符串， 那么应该按照下列步骤进行。 首先， 构建一个空的字符串构建器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuilder builder = <span class="keyword">new</span> StringBuilderO;</span><br></pre></td></tr></table></figure>

<p>当每次需要添加一部分内容时， 就调用 append 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">builder.append(ch); <span class="comment">// appends a single character</span></span><br><span class="line">bui1der.append(str); <span class="comment">// appends a string</span></span><br></pre></td></tr></table></figure>

<p>在需要构建字符串时就凋用 toString 方法， 将可以得到一个 String 对象， 其中包含了构建器中的字符序列。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String completedString = builder.toStringO;</span><br></pre></td></tr></table></figure>

<p><strong>StringBuffer和StringBuilder的区别</strong>：</p>
<ul>
<li>StringBuffer的效率较低，但允许采用多线程的方式执行添加或删除字符的操作</li>
<li>如果所有字符串在一个单线程中编辑（通常都是这样），则应该用StringBuilder代替</li>
<li>两个类的API是相同的</li>
</ul>
<h3 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h3><h4 id="读取输入"><a href="#读取输入" class="headerlink" title="读取输入"></a>读取输入</h4><p>要想通过控制台进行输人，首先需要构造一个 Scanner 对象，并与“ 标准输人流” System.in 关联。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br></pre></td></tr></table></figure>

<p>现在，就可以使用 Scanner 类的各种方法实现输入操作了。例如， nextLine 方法将输入一行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String name = in.nextLine();</span><br></pre></td></tr></table></figure>

<p>使用 nextLine 方法是因为在输人行中有可能包含空格。要想读取一个单词（以空白符作为分隔符，) 就调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String firstName = in.next()；</span><br></pre></td></tr></table></figure>

<p>要想读取一个整数，就调用 nextlnt 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> age = in.nextlnt();</span><br></pre></td></tr></table></figure>

<h4 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h4><p>可以使用 SyStem.0Ut.print(x) 将数值 x 输出到控制台上。这条命令将以 x 对应的数据类型所允许的最大非 0 数字位数打印输出 X。 例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> x = <span class="number">10000.0</span> / <span class="number">3.0</span>;</span><br><span class="line">System.out.print(x);  <span class="comment">//打印3333.3333333333335</span></span><br></pre></td></tr></table></figure>

<p>格式化输出可使用<strong>System.out.printf</strong>，在printf中，可以使用多个参数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.printf(<span class="string">"Hello, %s. Next year, you'll be SSd"</span>, name, age);</span><br></pre></td></tr></table></figure>

<p><img src="F:%5CBlog%5Cblog%5Csource%5Cimages%5C0003.PNG" alt="0003"></p>
<h4 id="文件输入与输出"><a href="#文件输入与输出" class="headerlink" title="文件输入与输出"></a>文件输入与输出</h4><p>要想对文件进行读取，就需要一个用 File 对象构造一个 Scanner 对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Scanner in = <span class="keyword">new</span> Scanner(Paths.get(<span class="string">"niyflle.txt"</span>), <span class="string">"UTF-8"</span>);</span><br></pre></td></tr></table></figure>

<p>要想写入文件， 就需要构造一个 PrintWriter 对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PrintWriter out = <span class="keyword">new</span> PrintlulriterC<span class="string">'myfile.txt", "UTF-8");</span></span><br></pre></td></tr></table></figure>

<p>要记住一点：如果用一个不存在的文件构造一个 Scanner，或者用一个不能被创建的文件名构造一个 PrintWriter，那么就会发生异常。</p>
<h3 id="控制流程"><a href="#控制流程" class="headerlink" title="控制流程"></a>控制流程</h3><h4 id="块作用域"><a href="#块作用域" class="headerlink" title="块作用域"></a>块作用域</h4><p>块（即复合语句）是指由一对大括号括起来的若干条简单的 Java 语句。块确定了变量的作用域。一个块可以嵌套在另一个块中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="keyword">int</span> k; </span><br><span class="line">	&#125; 	<span class="comment">// k is only defined up to here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) statement</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (condition) statement1 <span class="keyword">else</span> statement2</span><br></pre></td></tr></table></figure>

<h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (condition) statement</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> statement <span class="keyword">while</span> (condition)</span><br></pre></td></tr></table></figure>

<h4 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (statement1; condition; statement2)</span><br><span class="line">    statement3;</span><br></pre></td></tr></table></figure>

<h4 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h4><p>switch语句将从与选项值相匹配的 case 标签处开始执行直到遇到 break 语句，或者执行到switch i吾句的结束处为止。如果没有相匹配的 case 标签，而有 default 子句，就执行这个子句。（如果在case分支没有break语句的话，那么会接着执行下一个case分支）。</p>
<p>case标签可以是：</p>
<ul>
<li>类型为 char、byte、 short 或 int 的常量表达式。</li>
<li>枚举常量</li>
<li>从 Java SE 7开始， case 标签还可以是字符串字面量。</li>
</ul>
<h3 id="大数值"><a href="#大数值" class="headerlink" title="大数值"></a>大数值</h3><p>如果基本的整数和浮点数精度不能够满足需求，那么可以使用java.math 包中的两个很有用的类：Biglnteger 和 BigDecimal 这两个类可以处理包含任意长度数字序列的数值。Biglnteger 类实现了任意精度的整数运算，BigDecimal 实现了任意精度的浮点数运算。</p>
<p>使用静态的 valueOf方法可以将普通的数值转换为大数值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Biglnteger a = Biglnteger.valueOf(<span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<p>不能使用人们熟悉的算术运算符（如：+ 和 *) 处理大数值。 而需要使用大数值类中的 add 和 multiply 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Biglnteger c = a.add(b); <span class="comment">// c = a + b</span></span><br><span class="line">Biglnteger d = c.multiply(b.add(Biglnteger.valueOf(<span class="number">2</span>))); <span class="comment">// d = c * (b + 2)</span></span><br></pre></td></tr></table></figure>

<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组是一种数据结构， 用来存储同一类型值的集合。通过一个整型下标可以访问数组中的每一个值。在声明数组变量时， 需要指出数组类型 （ 数据元素类型紧跟 []) 和数组变量的名字。下面声明了整型数组 <strong>a</strong>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a;</span><br></pre></td></tr></table></figure>

<p>不过， 这条语句只声明了变量 <strong>a</strong>， 并没有将 <strong>a</strong> 初始化为一个真正的数组。应该使用 <strong>new</strong> 运算符创建数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>]; <span class="comment">//数组长度不要求是常量：newint[n]会创建一个长度为n的数组。</span></span><br></pre></td></tr></table></figure>

<h4 id="数组初始化以及匿名数组"><a href="#数组初始化以及匿名数组" class="headerlink" title="数组初始化以及匿名数组"></a>数组初始化以及匿名数组</h4><p>在 Java中， 提供了一种创建数组对象并同时赋予初始值的简化书写形式。下面是一 例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] smallPrimes = &#123; <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span> &#125;; </span><br><span class="line"><span class="comment">//请注意， 在使用这种语句时，不需要调用 new。</span></span><br></pre></td></tr></table></figure>

<p>甚至还可以初始化一个匿名的数组：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="keyword">int</span>[]&#123; <span class="number">17</span>, <span class="number">19</span>, <span class="number">23</span>, <span class="number">29</span>, <span class="number">31</span>, <span class="number">37</span> &#125;</span><br></pre></td></tr></table></figure>

<p>使用这种语法形式可以在不创建新变量的情况下重新初始化一个数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">smallPrimes = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123; <span class="number">17</span>, <span class="number">19</span>, <span class="number">23</span>, <span class="number">29</span>, <span class="number">31</span>, <span class="number">37</span> &#125;;</span><br></pre></td></tr></table></figure>

<h4 id="数组拷贝"><a href="#数组拷贝" class="headerlink" title="数组拷贝"></a>数组拷贝</h4><p>在 Java 中，允许将一个数组变量拷贝给另一个数组变量。这时，两个变量将引用同一个数组：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] luckyNumbers = smallPrimes; </span><br><span class="line">luckyNumbers[<span class="number">5</span>] = <span class="number">12</span>; <span class="comment">// now smallPrimes[5] is also 12</span></span><br></pre></td></tr></table></figure>

<p><img src="F:%5CBlog%5Cblog%5Csource%5Cimages%5C0004.PNG" alt="0004"></p>
<p><img src="http://static.runoob.com/images/demo/demo1.jpg" alt="text"></p>
<p>如果希望将一个数组的所有值拷贝到一个新的数组中去，就要使用 Arrays 类的 copyOf方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] copiedLuckyNumbers = Arrays.copyOf(luckyNumbers, luckyNumbers.length);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Core-Java-Fundamentals-Ⅱ</title>
    <url>/2020/03/04/Core-Java-Fundamentals-%E2%85%A1/</url>
    <content><![CDATA[<p><strong>这是摘要</strong>：等我有空再写！！！</p>
<a id="more"></a>

<h1 id="第-2-章-Java-程序设计环境"><a href="#第-2-章-Java-程序设计环境" class="headerlink" title="第 2 章 Java 程序设计环境"></a>第 2 章 Java 程序设计环境</h1><h2 id="安装Java开发工具包"><a href="#安装Java开发工具包" class="headerlink" title="安装Java开发工具包"></a>安装Java开发工具包</h2><ul>
<li>下载JDK</li>
<li>设置JDK的环境变量</li>
<li>安装库源文件和文档</li>
</ul>
<h2 id="使用命令行工具"><a href="#使用命令行工具" class="headerlink" title="使用命令行工具"></a>使用命令行工具</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">javac HelloWorld.java</span><br><span class="line">java HelloWorld</span><br></pre></td></tr></table></figure>

<ul>
<li>javac命令启动Java编译器，它将.java文件编译成.class文件。</li>
<li>java命令启动Java虚拟机，虚拟机执行编译器放在class文件中的字节码。</li>
</ul>
<p><strong>注意：使用java命令的时候，编译的程序后面不用加.class后缀</strong></p>
<h2 id="使用集成开发环境"><a href="#使用集成开发环境" class="headerlink" title="使用集成开发环境"></a>使用集成开发环境</h2><p>如JetBrains IntelliJ IDEA</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Core-Java-Fundamentals-Ⅰ</title>
    <url>/2020/03/04/Core-Java-Fundamentals-%E2%85%A0/</url>
    <content><![CDATA[<p><strong>这是摘要</strong>：等我有空再写！！！</p>
<a id="more"></a>

<h1 id="第一章-Java程序设计概述"><a href="#第一章-Java程序设计概述" class="headerlink" title="第一章 Java程序设计概述"></a>第一章 Java程序设计概述</h1><h2 id="Java的关键术语"><a href="#Java的关键术语" class="headerlink" title="Java的关键术语"></a>Java的关键术语</h2><ul>
<li>简单性</li>
<li>面向对象</li>
<li>分布式</li>
<li>健壮性</li>
<li>安全性</li>
<li>体系结构中立</li>
<li>可移植性</li>
<li>解释型</li>
<li>高性能</li>
<li>多线程</li>
<li>动态性</li>
</ul>
<h2 id="Java-applet与Internet"><a href="#Java-applet与Internet" class="headerlink" title="Java applet与Internet"></a>Java applet与Internet</h2><p>这里的想法很简单： 用户从 Internet 下载 Java 字节码， 并在自己的机器上运行。在网页中运行的 Java 程序称为 applet。要使用 applet, 需要启用 Java 的 Web 浏览器执行字节码。不需要安装任何软件。<br>任何时候只要访问包含 applet 的网页都会得到程序的最新版本。最重要的是，要感谢虚拟机的安全性，它让我们不必再担心来自恶意代码的攻击。在网页中插人一个 applet 就如同在网页中嵌人一幅图片。<br>applet 会成为页面的一部分。文本环绕着 applet 所占据的空间周围。关键的一点是这个图片是活动的。它可以对用户命令做出响应， 改变外观，在运行它的计算机与提供它的计算机之间传递数据。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode475-506</title>
    <url>/2020/03/03/leetcode475-506/</url>
    <content><![CDATA[<h1 id="LeetCode-探索：发散你的思维"><a href="#LeetCode-探索：发散你的思维" class="headerlink" title="LeetCode 探索：发散你的思维"></a>LeetCode 探索：发散你的思维</h1><a id="more"></a>

<h2 id="475-供暖器"><a href="#475-供暖器" class="headerlink" title="[475] 供暖器"></a>[475] 供暖器</h2><p><strong>冬季已经来临。 你的任务是设计一个有固定加热半径的供暖器向所有房屋供暖。</strong></p>
<p><strong>现在，给出位于一条水平线上的房屋和供暖器的位置，找到可以覆盖所有房屋的最小加热半径。</strong></p>
<p><strong>所以，你的输入将会是房屋和供暖器的位置。你将输出供暖器的最小加热半径。</strong></p>
<p><strong>说明:</strong></p>
<ol>
<li><strong>给出的房屋和供暖器的数目是非负数且不会超过 25000。</strong></li>
<li><strong>给出的房屋和供暖器的位置均是非负数且不会超过10^9。</strong></li>
<li><strong>只要房屋位于供暖器的半径内(包括在边缘上)，它就可以得到供暖。</strong></li>
<li><strong>所有供暖器都遵循你的半径标准，加热的半径也一样。</strong></li>
</ol>
<blockquote>
<p>首先将houses和heaters两个数组排序，然后对每一个house，寻找一个离它最近的heater，再取每一个最近距离的最大值</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @lc app=leetcode.cn id=475 lang=cpp</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [475] 供暖器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc code=start</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findRadius</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;houses, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;heaters)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        sort(houses.begin(), houses.end());</span><br><span class="line">        sort(heaters.begin(), heaters.end());</span><br><span class="line">        <span class="keyword">int</span> currMin = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; houses.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; heaters.size() &amp;&amp; heaters[j] &lt; houses[i])</span><br><span class="line">            &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = heaters[j] - houses[i];</span><br><span class="line">                currMin = max(currMin, temp);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (j &lt; heaters.size())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> temp1 = houses[i] - heaters[j - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">int</span> temp2 = heaters[j] - houses[i];</span><br><span class="line">                currMin = max(currMin, min(temp1, temp2));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (j == heaters.size())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = <span class="built_in">abs</span>(houses[i] - heaters[j - <span class="number">1</span>]);</span><br><span class="line">                currMin = max(currMin, temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> currMin;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">// @lc code=end</span></span><br></pre></td></tr></table></figure>

<h2 id="476-数字的补数"><a href="#476-数字的补数" class="headerlink" title="[476] 数字的补数"></a>[476] 数字的补数</h2><p><strong>给定一个正整数，输出它的补数。补数是对该数的二进制表示取反。</strong></p>
<blockquote>
<p>解题思路：获取每一位的值累加上去</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @lc app=leetcode.cn id=476 lang=cpp</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [476] 数字的补数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc code=start</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findComplement</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (num)</span><br><span class="line">        &#123;</span><br><span class="line">            res += !(num &amp; <span class="number">1</span>) &lt;&lt; n;</span><br><span class="line">            num &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            n++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">// @lc code=end</span></span><br></pre></td></tr></table></figure>

<h2 id="482-密钥格式化"><a href="#482-密钥格式化" class="headerlink" title="[482] 密钥格式化"></a>[482] 密钥格式化</h2><p><strong>给定一个密钥字符串S，只包含字母，数字以及 ‘-‘（破折号）。N 个 ‘-‘ 将字符串分成了 N+1 组。给定一个数字 K，重新格式化字符串，除了第一个分组以外，每个分组要包含 K 个字符，第一个分组至少要包含 1 个字符。两个分组之间用 ‘-‘（破折号）隔开，并且将所有的小写字母转换为大写字母。</strong></p>
<p><strong>给定非空字符串 S 和数字 K，按照上面描述的规则进行格式化。</strong></p>
<blockquote>
<p>解题思路：从后往前遍历构造，最后将结果尾部的’-‘除去，然后将其反转</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @lc app=leetcode.cn id=482 lang=cpp</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [482] 密钥格式化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc code=start</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">licenseKeyFormatting</span><span class="params">(<span class="built_in">string</span> S, <span class="keyword">int</span> K)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = S.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (count &lt; K)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (S[i] != <span class="string">'-'</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    res += (<span class="built_in">isalpha</span>(S[i]) != <span class="number">0</span> ? <span class="keyword">char</span>(<span class="built_in">toupper</span>(S[i])) : <span class="keyword">char</span>(S[i]));</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (count == K)</span><br><span class="line">            &#123;</span><br><span class="line">                res += <span class="string">"-"</span>;</span><br><span class="line">                count = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!res.empty() &amp;&amp; res.back() == <span class="string">'-'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(res.begin(), res.end());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">// @lc code=end</span></span><br></pre></td></tr></table></figure>

<h2 id="485-最大连续1的个数"><a href="#485-最大连续1的个数" class="headerlink" title="[485] 最大连续1的个数"></a>[485] 最大连续1的个数</h2><p><strong>给定一个二进制数组， 计算其中最大连续1的个数。</strong></p>
<blockquote>
<p>解题思路：使用一个计数器来记录连续1的数量，若数量较大则更新</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @lc app=leetcode.cn id=485 lang=cpp</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [485] 最大连续1的个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc code=start</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMaxConsecutiveOnes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> countMax=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==<span class="number">1</span>)</span><br><span class="line">                count++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                countMax = max(countMax,count);</span><br><span class="line">                count=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max(countMax,count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">// @lc code=end</span></span><br></pre></td></tr></table></figure>

<h2 id="492-构造矩形"><a href="#492-构造矩形" class="headerlink" title="[492] 构造矩形"></a>[492] 构造矩形</h2><p><strong>作为一位web开发者， 懂得怎样去规划一个页面的尺寸是很重要的。 现给定一个具体的矩形页面面积，你的任务是设计一个长度为 L 和宽度为 W 且满足以下要求的矩形的页面。要求：</strong></p>
<ol>
<li><p><strong>你设计的矩形页面必须等于给定的目标面积。</strong></p>
</li>
<li><p><strong>宽度 W 不应大于长度 L，换言之，要求 L &gt;= W 。</strong></p>
</li>
<li><p><strong>长度 L 和宽度 W 之间的差距应当尽可能小。</strong></p>
</li>
</ol>
<p><strong>你需要按顺序输出你设计的页面的长度 L 和宽度 W。</strong></p>
<blockquote>
<p>解题思路：从L = sqrt(area)开始，递减L，直到area % L == 0为止</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @lc app=leetcode.cn id=492 lang=cpp</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [492] 构造矩形</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc code=start</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">constructRectangle</span><span class="params">(<span class="keyword">int</span> area)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> w = <span class="built_in">sqrt</span>(area);</span><br><span class="line">        <span class="keyword">while</span> (area % w != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            w--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(&#123;area / w, w&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// @lc code=end</span></span><br></pre></td></tr></table></figure>

<h2 id="496-下一个更大元素-I"><a href="#496-下一个更大元素-I" class="headerlink" title="[496] 下一个更大元素 I"></a>[496] 下一个更大元素 I</h2><p><strong>给定两个没有重复元素的数组 nums1 和 nums2 ，其中nums1 是 nums2 的子集。找到 nums1 中每个元素在 nums2 中的下一个比其大的值。</strong></p>
<p><strong>nums1 中数字 x 的下一个更大元素是指 x 在 nums2 中对应位置的右边的第一个比 x 大的元素。如果不存在，对应位置输出-1。</strong></p>
<blockquote>
<p>解题思路：使用单调栈</p>
<ol>
<li>将元素入栈</li>
<li>当栈不为空时，若将要入栈的元素大于栈顶的元素，则将栈顶元素出栈，并将其(top, num[i])加入哈希表中，直到栈顶元素大于等于入栈元素，或栈为空时退出。</li>
<li>若将要入栈的元素小于栈顶的元素，则简单将其入栈</li>
<li>当数组的元素全部入栈后，若此时栈不为空，则将栈顶元素出栈，并将(top, -1)加入哈希表。</li>
</ol>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @lc app=leetcode.cn id=496 lang=cpp</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [496] 下一个更大元素 I</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc code=start</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">nextGreaterElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; table;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stacks;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums2.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stacks.empty() &amp;&amp; nums2[i] &gt; stacks.top())</span><br><span class="line">            &#123;</span><br><span class="line">                table.insert(make_pair(stacks.top(), nums2[i]));</span><br><span class="line">                stacks.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            stacks.push(nums2[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!stacks.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            table.insert(make_pair(stacks.top(), <span class="number">-1</span>));</span><br><span class="line">            stacks.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums1.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(table[nums1[i]]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// @lc code=end</span></span><br></pre></td></tr></table></figure>

<h2 id="500-键盘行"><a href="#500-键盘行" class="headerlink" title="[500] 键盘行"></a>[500] 键盘行</h2><p><strong>给定一个单词列表，只返回可以使用在键盘同一行的字母打印出来的单词。键盘如下图所示。</strong></p>
<blockquote>
<p>解题思路：对每一个单词的每一个字母都进行判断在哪一行，若同一个单词在不同行有字母，则退出循环，并判断</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @lc app=leetcode.cn id=500 lang=cpp</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [500] 键盘行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc code=start</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">findWords</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;words)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> patterns[<span class="number">3</span>] = &#123;<span class="string">"qwertyuiopQWERTYUIOP"</span>, <span class="string">"asdfghjklASDFGHJKL"</span>, <span class="string">"zxcvbnmZXCVBNM"</span>&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">string</span> word : words)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> flag[<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> c : word)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (patterns[i].find(c) != <span class="built_in">string</span>::npos)</span><br><span class="line">                        flag[i] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (flag[<span class="number">0</span>] + flag[<span class="number">1</span>] + flag[<span class="number">2</span>] &gt; <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag[<span class="number">0</span>] + flag[<span class="number">1</span>] + flag[<span class="number">2</span>] == <span class="number">1</span>)</span><br><span class="line">                res.push_back(word);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// @lc code=end</span></span><br></pre></td></tr></table></figure>

<h2 id="501-二叉搜索树中的众数"><a href="#501-二叉搜索树中的众数" class="headerlink" title="[501] 二叉搜索树中的众数"></a>[501] 二叉搜索树中的众数</h2><p><strong>给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。</strong></p>
<blockquote>
<p>解题思路：递归，记录父节点的值，再与子节点的值进行比较</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @lc app=leetcode.cn id=501 lang=cpp</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [501] 二叉搜索树中的众数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc code=start</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">int</span> maxCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    TreeNode *pre;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">travel</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        travel(root-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (pre != <span class="literal">NULL</span> &amp;&amp; pre-&gt;val == root-&gt;val)</span><br><span class="line">            count++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (count == maxCount)</span><br><span class="line">            res.push_back(root-&gt;val);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (count &gt; maxCount)</span><br><span class="line">        &#123;</span><br><span class="line">            maxCount = count;</span><br><span class="line">            res.clear();</span><br><span class="line">            res.push_back(root-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        pre = root;</span><br><span class="line">        travel(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findMode</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        travel(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// @lc code=end</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>解题思路：使用Hash-table，注意遍历的时候不要使用下标，要使用迭代器</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">travel</span><span class="params">(TreeNode *root, <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp;table)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        travel(root-&gt;left, table);</span><br><span class="line">        table[root-&gt;val]++;</span><br><span class="line">        travel(root-&gt;right, table);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findMode</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; table;</span><br><span class="line">        travel(root, table);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">int</span> M = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = table.begin(); i != table.end(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            M = max(M, i-&gt;second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = table.begin(); i != table.end(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i-&gt;second == M)</span><br><span class="line">                res.push_back(i-&gt;first);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="504-七进制数"><a href="#504-七进制数" class="headerlink" title="[504] 七进制数"></a>[504] 七进制数</h2><p><strong>给定一个整数，将其转化为7进制，并以字符串形式输出。</strong></p>
<blockquote>
<p>解题思路：将负数换成正数处理，同时需要单独处理0的情况</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @lc app=leetcode.cn id=504 lang=cpp</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [504] 七进制数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc code=start</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">convertToBase7</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">        <span class="built_in">string</span> str = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> n = num;</span><br><span class="line">        <span class="keyword">if</span> (num &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            n = -num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            str += to_string(n % <span class="number">7</span>);</span><br><span class="line">            n /= <span class="number">7</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(str.begin(), str.end());</span><br><span class="line">        <span class="keyword">return</span> num &gt; <span class="number">0</span> ? str : <span class="string">"-"</span> + str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// @lc code=end</span></span><br></pre></td></tr></table></figure>

<h2 id="506-相对名次"><a href="#506-相对名次" class="headerlink" title="[506] 相对名次"></a>[506] 相对名次</h2><p><strong>给出 N 名运动员的成绩，找出他们的相对名次并授予前三名对应的奖牌。前三名运动员将会被分别授予 “金牌”，“银牌” 和“ 铜牌”（”Gold Medal”, “Silver Medal”, “Bronze Medal”）。</strong></p>
<p><strong>(注：分数越高的选手，排名越靠前。)</strong></p>
<blockquote>
<p>解题思路：使用map的有序特性</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @lc app=leetcode.cn id=506 lang=cpp</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [506] 相对名次</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc code=start</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;n, <span class="keyword">const</span> <span class="keyword">int</span> &amp;m)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n &gt; m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">findRelativeRanks</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = nums.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">res</span><span class="params">(size)</span></span>;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; table;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)</span><br><span class="line">            table[nums[i]] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = table.begin(); i != table.end(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (size == <span class="number">1</span>)</span><br><span class="line">                res[i-&gt;second] = <span class="string">"Gold Medal"</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (size == <span class="number">2</span>)</span><br><span class="line">                res[i-&gt;second] = <span class="string">"Silver Medal"</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (size == <span class="number">3</span>)</span><br><span class="line">                res[i-&gt;second] = <span class="string">"Bronze Medal"</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                res[i-&gt;second] = to_string(size);</span><br><span class="line">            size--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// @lc code=end</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeyouStore</title>
    <url>/2020/02/29/LeyouStore/</url>
    <content><![CDATA[<p><strong>这是摘要</strong>：等我有空再写！！！</p>
<a id="more"></a>

<h2 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h2><p>Webpack是一个前端资源的打包工具，它可以将HTML、CSS、JS等资源当成一个模块进行打包。<a href="https://webpack.js.org" target="_blank" rel="noopener">Webpck</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode437-463</title>
    <url>/2020/02/29/leetcode437-463/</url>
    <content><![CDATA[<h1 id="LeetCode-探索：发散你的思维"><a href="#LeetCode-探索：发散你的思维" class="headerlink" title="LeetCode 探索：发散你的思维"></a>LeetCode 探索：发散你的思维</h1><a id="more"></a>

<h2 id="437-路径总和-III"><a href="#437-路径总和-III" class="headerlink" title="[437] 路径总和 III"></a>[437] 路径总和 III</h2><p><strong>给定一个二叉树，它的每个结点都存放着一个整数值。</strong></p>
<p><strong>找出路径和等于给定数值的路径总数。</strong></p>
<p><strong>路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</strong></p>
<p><strong>二叉树不超过1000个节点，且节点数值范围是 [-1000000, 1000000] 的整数。</strong></p>
<blockquote>
<p>解题思路：将路径分为包含root节点和不包含root节点的情况，分别进行递归</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @lc app=leetcode.cn id=437 lang=cpp</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [437] 路径总和 III</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc code=start</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val; </span></span><br><span class="line"><span class="comment"> *     TreeNode *left; </span></span><br><span class="line"><span class="comment"> *     TreeNode *right; </span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;; </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode *root, <span class="keyword">int</span> sum)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当前节点的值等于sum时，则加一</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val == sum)</span><br><span class="line">            res++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里为不包含root节点的路径</span></span><br><span class="line">        res += pathSum(root-&gt;left, sum);</span><br><span class="line">        res += pathSum(root-&gt;right, sum);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//包含root节点的路径</span></span><br><span class="line">        <span class="comment">//这里不能直接调用pathSum，这样会造成断开的路径</span></span><br><span class="line">        res += pathSumInclude(root-&gt;left, sum - root-&gt;val);</span><br><span class="line">        res += pathSumInclude(root-&gt;right, sum - root-&gt;val);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pathSumInclude</span><span class="params">(TreeNode *root, <span class="keyword">int</span> sum)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val == sum)</span><br><span class="line">            res++; </span><br><span class="line">        res += pathSumInclude(root-&gt;left, sum - root-&gt;val); </span><br><span class="line">        res += pathSumInclude(root-&gt;right, sum - root-&gt;val); </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">// @lc code=end</span></span><br></pre></td></tr></table></figure>

<h2 id="441-排列硬币"><a href="#441-排列硬币" class="headerlink" title="[441] 排列硬币"></a>[441] 排列硬币</h2><p><strong>你总共有 n 枚硬币，你需要将它们摆成一个阶梯形状，第 k 行就必须正好有 k 枚硬币。</strong></p>
<p><strong>给定一个数字 n，找出可形成完整阶梯行的总行数。</strong></p>
<p><strong>n 是一个非负整数，并且在32位有符号整型的范围内。</strong></p>
<blockquote>
<p>解题思路：使用等差数列的通项公式</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @lc app=leetcode.cn id=441 lang=cpp</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [441] 排列硬币</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc code=start</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">arrangeCoins</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ((i * i + i) / <span class="number">2</span> &gt; n)</span><br><span class="line">                <span class="keyword">return</span> i - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((i * i + i) / <span class="number">2</span> == n)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">// @lc code=end</span></span><br></pre></td></tr></table></figure>

<h2 id="443-压缩字符串"><a href="#443-压缩字符串" class="headerlink" title="[443] 压缩字符串"></a>[443] 压缩字符串</h2><p><strong>给定一组字符，使用原地算法将其压缩。</strong></p>
<p><strong>压缩后的长度必须始终小于或等于原数组长度。</strong></p>
<p><strong>数组的每个元素应该是长度为1 的字符（不是 int 整数类型）。</strong></p>
<p><strong>在完成原地修改输入数组后，返回数组的新长度。</strong></p>
<blockquote>
<p>解题思路：使用双指针方法，一个read指针和一个write指针，均从左边开始移动</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @lc app=leetcode.cn id=443 lang=cpp</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [443] 压缩字符串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc code=start</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用双指针方法，一个read指针和一个write指针，均从左边开始移动</span></span><br><span class="line">    <span class="comment">//anchor指针用于标记相同连续字符子串的第一个字符</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compress</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; &amp;chars)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> anchor = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> write = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> read = <span class="number">0</span>; read &lt; chars.size(); read++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//当遇到不同的字符或到达字符串末尾时</span></span><br><span class="line">            <span class="keyword">if</span> (read + <span class="number">1</span> == chars.size() || chars[read] != chars[read + <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                chars[write++] = chars[anchor];</span><br><span class="line">                <span class="comment">//当相同连续的字符数大于1时</span></span><br><span class="line">                <span class="keyword">if</span> (read &gt; anchor)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">string</span> num = to_string(read - anchor + <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">char</span> c : num)</span><br><span class="line">                        chars[write++] = c;</span><br><span class="line">                &#125;</span><br><span class="line">                anchor = read + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> write;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">// @lc code=end</span></span><br></pre></td></tr></table></figure>

<h2 id="447-回旋镖的数量"><a href="#447-回旋镖的数量" class="headerlink" title="[447] 回旋镖的数量"></a>[447] 回旋镖的数量</h2><p><strong>给定平面上 n 对不同的点，“回旋镖” 是由点表示的元组 (i, j, k) ，其中 i 和 j 之间的距离和 i 和 k 之间的距离相等（需要考虑元组的顺序）。</strong></p>
<p><strong>找到所有回旋镖的数量。你可以假设 n 最大为 500，所有点的坐标在闭区间 [-10000, 10000] 中。</strong></p>
<blockquote>
<p>解题思路：使用哈希表，记录相同距离的点的数量</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @lc app=leetcode.cn id=447 lang=cpp</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [447] 回旋镖的数量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc code=start</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getDistance</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; q)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pow</span>(p[<span class="number">0</span>] - q[<span class="number">0</span>], <span class="number">2</span>) + <span class="built_in">pow</span>(p[<span class="number">1</span>] - q[<span class="number">1</span>], <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numberOfBoomerangs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;points)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>; </span><br><span class="line">        vector&lt;map&lt;int, int&gt;&gt; dis(points.size()); </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; points.size() - <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; points.size(); j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> d = getDistance(points[i], points[j]); </span><br><span class="line">                res += <span class="number">2</span> * (dis[i][d] + dis[j][d]); </span><br><span class="line">                dis[i][d]++; </span><br><span class="line">                dis[j][d]++; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">// @lc code=end</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>解题思路：使用距离矩阵，预排序</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numberOfBoomerangs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;points)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dis[points.size()][points.size()];</span><br><span class="line">        <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//计算距离矩阵</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; points.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; points.size(); ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                dis[i][j] = <span class="built_in">pow</span>(points[i][<span class="number">0</span>] - points[j][<span class="number">0</span>], <span class="number">2</span>) + <span class="built_in">pow</span>(points[i][<span class="number">1</span>] - points[j][<span class="number">1</span>], <span class="number">2</span>);</span><br><span class="line">                dis[j][i] = dis[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; points.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//对距离矩阵预排序</span></span><br><span class="line">            sort(dis[i], dis[i] + points.size());</span><br><span class="line">            <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; points.size(); ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//对相同距离的点进行计数</span></span><br><span class="line">                <span class="keyword">if</span> (dis[i][j] == dis[i][j - <span class="number">1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    num++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//当计数量不为0时，即相同距离的点有两个及以上</span></span><br><span class="line">                    <span class="keyword">if</span> (num != <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        number += factorial(num + <span class="number">1</span>);</span><br><span class="line">                        num = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (num != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                number += factorial(num + <span class="number">1</span>);</span><br><span class="line">                num = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> number;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">factorial</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> group = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">6</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = num; i &gt; <span class="number">2</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            group *= i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> group;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="448-找到所有数组中消失的数字"><a href="#448-找到所有数组中消失的数字" class="headerlink" title="[448] 找到所有数组中消失的数字"></a>[448] 找到所有数组中消失的数字</h2><p><strong>给定一个范围在  1 ≤ a[i] ≤ n ( n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。</strong></p>
<p><strong>找到所有在 [1, n] 范围之间没有出现在数组中的数字。</strong></p>
<p><strong>您能在不使用额外空间且时间复杂度为O(n)的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。</strong></p>
<blockquote>
<p>解题思路：<br>方法一，使用哈希表。<br>方法二，遍历输入数组的每个元素一次。<br>我们将把 |nums[i]|-1 索引位置的元素标记为负数。即 nums[|nums[i] |- 1] = -|nums[∣nums[i]∣−1]|.<br>然后遍历数组，若当前数组元素 nums[i] 为负数，说明我们在数组中存在数字 i+1。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @lc app=leetcode.cn id=448 lang=cpp</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [448] 找到所有数组中消失的数字</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc code=start</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findDisappearedNumbers</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            nums[<span class="built_in">abs</span>(nums[i]) - <span class="number">1</span>] = -<span class="built_in">abs</span>(nums[<span class="built_in">abs</span>(nums[i]) - <span class="number">1</span>]); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>)</span><br><span class="line">                res.push_back(i + <span class="number">1</span>); </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">// @lc code=end</span></span><br></pre></td></tr></table></figure>

<h2 id="453-最小移动次数使数组元素相等"><a href="#453-最小移动次数使数组元素相等" class="headerlink" title="[453] 最小移动次数使数组元素相等"></a>[453] 最小移动次数使数组元素相等</h2><p><strong>给定一个长度为 n 的非空整数数组，找到让数组所有元素相等的最小移动次数。每次移动可以使 n - 1 个元素增加 1。</strong></p>
<blockquote>
<p>解题思路：首先，假设我们在每一步计算 diff 之后正在更新有序数组的元素。下面展示如何在不遍历数组的情况下找到最大最小值。在第一步中，最后的元素即为最大值，因此 diff=a[n-1]-a[0]。我们对除了最后一个元素以外所有元素增加 diff。</p>
</blockquote>
<blockquote>
<p>现在，更新后的数组开头元素 a’[0] 变成了 a[0]+diff=a[n-1]。因此，a’[0] 等于上一步中最大的元素 a[n-1]。由于数组排过序，直到 i-2 的元素都满足 a[j]&gt;=a[j-1]。因此，更新之后，a’[n-2] 即为最大元素。而 a[0] 依然是最小元素。</p>
</blockquote>
<blockquote>
<p>于是，在第二次更新时，diff=a[n-2]-a[0]。更新后 a’’[0] 会成为 a’[n-2]，与上一次迭代类似。</p>
</blockquote>
<blockquote>
<p>然后，由于 a’[0] 和 a’[n-1] 相等，在第二次更新后，a’’[0]=a’’[n-1]=a’[n-2]。于是，最大的元素为 a[n-3]。</p>
</blockquote>
<blockquote>
<p>于是，我们可以继续这样，在每一步用最大最小值差更新数组。</p>
</blockquote>
<blockquote>
<p>下面进入第二步。第一步中，我们假设每一步会更新数组 aa 中的元素。但事实上，我们不需要这么做。这是因为，即使是在更新元素之后，我们要登记的 diff 差值也不变，因为 max 和 min 增加的数字相同。</p>
</blockquote>
<blockquote>
<p>于是，我们可以简单的将数组排序一次， $moves=\sum_{i=1}^{n-1} (a[i]-a[0])$。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @lc app=leetcode.cn id=453 lang=cpp</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [453] 最小移动次数使数组元素相等</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc code=start</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minMoves</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> moves = <span class="number">0</span>;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            moves += (nums[i] - nums[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> moves;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">// @lc code=end</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>解题思路：该方法基于以下思路：将除了一个元素之外的全部元素+1，等价于将该元素-1，因为我们只对元素的相对大小感兴趣。因此，该问题简化为需要进行的减法次数。</p>
</blockquote>
<blockquote>
<p>显然，我们只需要将所有的数都减到最小的数即可。为了找到答案，我们不需要真的操作这些元素。只需要 $moves=\sum_{i=0}^{n-1} a[i] - min(a)*n$即可，其中 nn 为数组的数量。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @lc app=leetcode.cn id=453 lang=cpp</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [453] 最小移动次数使数组元素相等</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc code=start</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minMoves</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> moves = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            moves += nums[i];</span><br><span class="line">            m = min(m, nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> moves - m * nums.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">// @lc code=end</span></span><br></pre></td></tr></table></figure>

<h2 id="455-分发饼干"><a href="#455-分发饼干" class="headerlink" title="[455] 分发饼干"></a>[455] 分发饼干</h2><p><strong>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。对每个孩子 i ，都有一个胃口值 gi ，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j ，都有一个尺寸 sj 。如果 sj &gt;= gi ，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</strong></p>
<blockquote>
<p>解题思路：贪心算法。先对两个数组进行预排序，然后从左到右扫描，对于未分配饼干的需求量最小的孩子分配一个最小最适合的饼干</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @lc app=leetcode.cn id=455 lang=cpp</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [455] 分发饼干</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc code=start</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findContentChildren</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;g, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        sort(g.begin(), g.end());</span><br><span class="line">        sort(s.begin(), s.end());</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; s.size() &amp;&amp; s[j] &lt; g[i])</span><br><span class="line">            &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; s.size())</span><br><span class="line">                count++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">// @lc code=end</span></span><br></pre></td></tr></table></figure>

<h2 id="459-重复的子字符串"><a href="#459-重复的子字符串" class="headerlink" title="[459] 重复的子字符串"></a>[459] 重复的子字符串</h2><p><strong>给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @lc app=leetcode.cn id=459 lang=cpp</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [459] 重复的子字符串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc code=start</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">repeatedSubstringPattern</span><span class="params">(<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (s + s).find(s, <span class="number">1</span>) != s.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">// @lc code=end</span></span><br></pre></td></tr></table></figure>

<h2 id="461-汉明距离"><a href="#461-汉明距离" class="headerlink" title="[461] 汉明距离"></a>[461] 汉明距离</h2><p><strong>两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。</strong></p>
<p><strong>给出两个整数 x 和 y，计算它们之间的汉明距离。</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @lc app=leetcode.cn id=461 lang=cpp</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [461] 汉明距离</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc code=start</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> z = x ^ y;</span><br><span class="line">        <span class="keyword">while</span> (z != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (z &amp; <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            z = z &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// @lc code=end</span></span><br></pre></td></tr></table></figure>

<h2 id="463-岛屿的周长"><a href="#463-岛屿的周长" class="headerlink" title="[463] 岛屿的周长"></a>[463] 岛屿的周长</h2><p><strong>给定一个包含 0 和 1 的二维网格地图，其中 1 表示陆地 0 表示水域。</strong></p>
<p><strong>网格中的格子水平和垂直方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。</strong></p>
<p><strong>岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @lc app=leetcode.cn id=463 lang=cpp</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [463] 岛屿的周长</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc code=start</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">islandPerimeter</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;grid)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[i].size(); j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i == <span class="number">0</span> || grid[i - <span class="number">1</span>][j] == <span class="number">0</span>)</span><br><span class="line">                        res++;</span><br><span class="line">                    <span class="keyword">if</span> (j == <span class="number">0</span> || grid[i][j - <span class="number">1</span>] == <span class="number">0</span>)</span><br><span class="line">                        res++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// @lc code=end</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode389-434</title>
    <url>/2020/02/28/leetcode389-434/</url>
    <content><![CDATA[<h1 id="LeetCode-探索：发散你的思维"><a href="#LeetCode-探索：发散你的思维" class="headerlink" title="LeetCode 探索：发散你的思维"></a>LeetCode 探索：发散你的思维</h1><a id="more"></a>

<h2 id="389-找不同"><a href="#389-找不同" class="headerlink" title="[389] 找不同"></a>[389] 找不同</h2><p><strong>给定两个字符串 s 和 t，它们只包含小写字母。</strong></p>
<p><strong>字符串 t 由字符串 s 随机重排，然后在随机位置添加一个字母。</strong></p>
<p><strong>请找出在 t 中被添加的字母。</strong></p>
<blockquote>
<p>解题思路：使用异或操作，两个字符串中成对的字符进行异或得到0，0再和多出来的一个字符c异或，则得到c</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @lc app=leetcode.cn id=389 lang=cpp</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [389] 找不同</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc code=start</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">findTheDifference</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s)</span><br><span class="line">            res ^= c;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : t)</span><br><span class="line">            res ^= c;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">// @lc code=end</span></span><br></pre></td></tr></table></figure>

<h2 id="392-判断子序列"><a href="#392-判断子序列" class="headerlink" title="[392] 判断子序列"></a>[392] 判断子序列</h2><p><strong>给定字符串 s 和 t ，判断 s 是否为 t 的子序列。你可以认为 s 和 t 中仅包含英文小写字母。字符串 t 可能会很长（长度 ~= 500, 000），而 s 是个短字符串（长度 &lt;=100）。字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，”ace”是”abcde”的一个子序列，而”aec”不是）。</strong></p>
<blockquote>
<p>解题思路：以-1为起始点，每次从index + 1中找出t是否存在字符s[i]，若不存在，则返回false；循环退出的时候返回true。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @lc app=leetcode.cn id=392 lang=cpp</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [392] 判断子序列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc code=start</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubsequence</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            index = t.find_first_of(s[i], index + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (index == <span class="built_in">string</span>::npos)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">// @lc code=end</span></span><br></pre></td></tr></table></figure>

<h2 id="401-二进制手表"><a href="#401-二进制手表" class="headerlink" title="[401] 二进制手表"></a>[401] 二进制手表</h2><p><strong>二进制手表顶部有 4 个 LED 代表小时（0-11），底部的 6 个 LED 代表分钟（0-59）。每个 LED 代表一个 0 或 1，最低位在右侧。给定一个非负整数 n 代表当前 LED 亮着的数量，返回所有可能的时间。</strong></p>
<blockquote>
<p>解题思路：暴力穷举，计算每一个情况出现的1的次数</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @lc app=leetcode.cn id=401 lang=cpp</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [401] 二进制手表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc code=start</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算数字n的二进制中的1的数量</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            n = n &amp; (n - <span class="number">1</span>);</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//直接遍历0:00-12:00，看有多少个符合要求的，并将其加入结果</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">readBinaryWatch</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">12</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (count(i) == num)</span><br><span class="line">                res.push_back(to_string(i) + <span class="string">":00"</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">60</span>; j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (count(i) + count(j) == num)</span><br><span class="line">                        res.push_back(to_string(i) + <span class="string">":"</span> + ((j &lt; <span class="number">10</span>) ? <span class="string">"0"</span> + to_string(j) : to_string(j)));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">// @lc code=end</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>解题思路：回溯算法</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">enumerate</span><span class="params">(<span class="keyword">int</span> digit, <span class="keyword">int</span> n, <span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            ret.push_back(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (digit &lt;= n) &#123;</span><br><span class="line">            <span class="keyword">int</span> shift = (<span class="number">1</span> &lt;&lt; digit) - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (shift &lt; limit) &#123;</span><br><span class="line">                ret.push_back(shift);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; off = enumerate(digit - <span class="number">1</span>, n, limit);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> high: off) &#123;</span><br><span class="line">            <span class="keyword">int</span> shift = high &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (shift &lt; limit) &#123;</span><br><span class="line">                ret.push_back(shift);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; on = enumerate(digit - <span class="number">1</span>, n - <span class="number">1</span>, limit);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> high: on) &#123;</span><br><span class="line">            <span class="keyword">int</span> shift = (high &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (shift &lt; limit) &#123;</span><br><span class="line">                ret.push_back(shift);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">readBinaryWatch</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> min = num&lt;<span class="number">4</span>? num: <span class="number">4</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ret;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=min; i++) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; hour = enumerate(<span class="number">4</span>, i, <span class="number">12</span>);</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; minute = enumerate(<span class="number">6</span>, num - i, <span class="number">60</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> h: hour) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> m: minute) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (m &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">                        <span class="built_in">string</span> s = to_string(h) + <span class="string">":"</span> + to_string(m);</span><br><span class="line">                        ret.push_back(s);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="built_in">string</span> s = to_string(h) + <span class="string">":0"</span> + to_string(m);</span><br><span class="line">                        ret.push_back(s);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="404-左叶子之和"><a href="#404-左叶子之和" class="headerlink" title="[404] 左叶子之和"></a>[404] 左叶子之和</h2><p><strong>计算给定二叉树的所有左叶子之和。</strong></p>
<blockquote>
<p>解题思路：迭代，使用队列对树进行遍历，当队列不为空时，执行循环</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @lc app=leetcode.cn id=404 lang=cpp</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [404] 左叶子之和</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc code=start</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val; </span></span><br><span class="line"><span class="comment"> *     TreeNode *left; </span></span><br><span class="line"><span class="comment"> *     TreeNode *right; </span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;; </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isLeaf</span><span class="params">(TreeNode *node)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> node-&gt;left == <span class="literal">NULL</span> &amp;&amp; node-&gt;right == <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode *&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode *node = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (isLeaf(node-&gt;left))</span><br><span class="line">                    sum += node-&gt;left-&gt;val;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    q.push(node-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">                q.push(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">// @lc code=end</span></span><br></pre></td></tr></table></figure>

<h2 id="405-数字转换为十六进制数"><a href="#405-数字转换为十六进制数" class="headerlink" title="[405] 数字转换为十六进制数"></a>[405] 数字转换为十六进制数</h2><p><strong>给定一个整数，编写一个算法将这个数转换为十六进制数。对于负整数，我们通常使用 补码运算 方法。</strong></p>
<p><strong>注意:</strong></p>
<ol>
<li><strong>十六进制中所有字母(a-f)都必须是小写。</strong></li>
<li><strong>十六进制字符串中不能包含多余的前导零。如果要转化的数为0，那么以单个字符’0’来表示；对于其他情况，十六进制字符串中的第一个字符将不会是0字符。</strong></li>
<li><strong>给定的数确保在32位有符号整数范围内。</strong></li>
<li><strong>不能使用任何由库提供的将数字直接转换或格式化为十六进制的方法。</strong></li>
</ol>
<blockquote>
<p>解题思路：将int类型转换为unsigned int类型计算，会自动对负数进行补码表示</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @lc app=leetcode.cn id=405 lang=cpp</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [405] 数字转换为十六进制数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc code=start</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">toHex</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">        <span class="built_in">string</span> <span class="built_in">map</span>[<span class="number">16</span>] = &#123;<span class="string">"0"</span>, <span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>, <span class="string">"6"</span>, <span class="string">"7"</span>, <span class="string">"8"</span>, <span class="string">"9"</span>, <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>, <span class="string">"e"</span>, <span class="string">"f"</span>&#125;;</span><br><span class="line">        <span class="built_in">string</span> res = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> n = num;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = n % <span class="number">16</span>;</span><br><span class="line">            n /= <span class="number">16</span>;</span><br><span class="line">            res = <span class="built_in">map</span>[temp] + res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">// @lc code=end</span></span><br></pre></td></tr></table></figure>

<h2 id="409-最长回文串"><a href="#409-最长回文串" class="headerlink" title="[409] 最长回文串"></a>[409] 最长回文串</h2><p><strong>给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。</strong></p>
<p><strong>在构造过程中，请注意区分大小写。比如 “Aa” 不能当做一个回文字符串。</strong></p>
<blockquote>
<p>解题思路：使用哈希表</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @lc app=leetcode.cn id=409 lang=cpp</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [409] 最长回文串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc code=start</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> table[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s)</span><br><span class="line">            table[c]++;</span><br><span class="line">        <span class="keyword">int</span> add = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">65</span>; i &lt;= <span class="number">122</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (table[i] &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (table[i] % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">                    sum += table[i];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    sum += (table[i] - <span class="number">1</span>);</span><br><span class="line">                    add = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum + add;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">// @lc code=end</span></span><br></pre></td></tr></table></figure>

<h2 id="412-Fizz-Buzz"><a href="#412-Fizz-Buzz" class="headerlink" title="[412] Fizz Buzz"></a>[412] Fizz Buzz</h2><p><strong>写一个程序，输出从 1 到 n 数字的字符串表示。</strong></p>
<ol>
<li><p><strong>如果 n 是3的倍数，输出“Fizz”；</strong></p>
</li>
<li><p><strong>如果 n 是5的倍数，输出“Buzz”；</strong></p>
</li>
<li><p><strong>如果 n 同时是3和5的倍数，输出 “FizzBuzz”。</strong></p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @lc app=leetcode.cn id=412 lang=cpp</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [412] Fizz Buzz</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc code=start</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">fizzBuzz</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">0</span> &amp;&amp; i % <span class="number">5</span> == <span class="number">0</span>)</span><br><span class="line">                res.push_back(<span class="string">"FizzBuzz"</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">                res.push_back(<span class="string">"Fizz"</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i % <span class="number">5</span> == <span class="number">0</span>)</span><br><span class="line">                res.push_back(<span class="string">"Buzz"</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                res.push_back(to_string(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">// @lc code=end</span></span><br></pre></td></tr></table></figure>

<h2 id="414-第三大的数"><a href="#414-第三大的数" class="headerlink" title="[414] 第三大的数"></a>[414] 第三大的数</h2><p><strong>给定一个非空数组，返回此数组中第三大的数。如果不存在，则返回数组中最大的数。要求算法时间复杂度必须是O(n)。</strong></p>
<blockquote>
<p>解题思路：利用set集合的元素的唯一性和有序性</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @lc app=leetcode.cn id=414 lang=cpp</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [414] 第三大的数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc code=start</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">thirdMax</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; <span class="title">table</span><span class="params">(nums.begin(), nums.end())</span></span>;</span><br><span class="line">        <span class="keyword">auto</span> it = table.end();</span><br><span class="line">        <span class="keyword">if</span> (table.size() &gt;= <span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            it--;</span><br><span class="line">            it--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *(--it);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">// @lc code=end</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>解题思路：用三个变量来储存第一第二第三大的数，并同时替换</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @lc app=leetcode.cn id=414 lang=cpp</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [414] 第三大的数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc code=start</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">thirdMax</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> first = <span class="number">-2147483653</span>;</span><br><span class="line">        <span class="keyword">long</span> second = <span class="number">-2147483654</span>;</span><br><span class="line">        <span class="keyword">long</span> third = <span class="number">-2147483655</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; first)</span><br><span class="line">            &#123;</span><br><span class="line">                third = second;</span><br><span class="line">                second = first;</span><br><span class="line">                first = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] &lt; first &amp;&amp; nums[i] &gt; second)</span><br><span class="line">            &#123;</span><br><span class="line">                third = second;</span><br><span class="line">                second = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] &lt; second &amp;&amp; nums[i] &gt; third)</span><br><span class="line">            &#123;</span><br><span class="line">                third = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (third &lt; <span class="number">-2147483648</span>) ? (<span class="keyword">int</span>)first : (<span class="keyword">int</span>)third;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">// @lc code=end</span></span><br></pre></td></tr></table></figure>

<h2 id="415-字符串相加"><a href="#415-字符串相加" class="headerlink" title="[415] 字符串相加"></a>[415] 字符串相加</h2><p><strong>给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和。</strong></p>
<p><strong>注意：</strong></p>
<ol>
<li><strong>num1 和num2 的长度都小于 5100.</strong></li>
<li><strong>num1 和num2 都只包含数字 0-9.</strong></li>
<li><strong>num1 和num2 都不包含任何前导零。</strong></li>
<li><strong>你不能使用任何內建 BigInteger 库， 也不能直接将输入的字符串转换为整数形式。</strong></li>
</ol>
<blockquote>
<p>解题思路：</p>
<ul>
<li>算法流程： 设定 i，j 两指针分别指向 num1，num2 尾部，模拟人工加法；</li>
</ul>
<ul>
<li>计算进位： 计算 carry = tmp // 10，代表当前位相加是否产生进位；</li>
<li>添加当前位： 计算 tmp = n1 + n2 + carry，并将当前位 tmp % 10 添加至 res 头部；</li>
<li>索引溢出处理： 当指针 i或j 走过数字首部后，给 n1，n2 赋值为 00，相当于给 num1，num2 中长度较短的数字前面填 00，以便后续计算。</li>
<li>当遍历完 num1，num2 后跳出循环，并根据 carry 值决定是否在头部添加进位 11，最终返回 res 即可。</li>
</ul>
<ul>
<li>复杂度分析：</li>
</ul>
<ul>
<li>时间复杂度 O(max(M, N))O(max(M, N))：其中 MM，NN 为 22 数字长度，按位遍历一遍数字（以较长的数字为准）；空间复杂度 O(1)O(1)：指针与变量使用常数大小空间。</li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @lc app=leetcode.cn id=415 lang=cpp</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [415] 字符串相加</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc code=start</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">addStrings</span><span class="params">(<span class="built_in">string</span> num1, <span class="built_in">string</span> num2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> i = num1.length() - <span class="number">1</span>, j = num2.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> n1 = (i &gt;= <span class="number">0</span>) ? num1[i] - <span class="string">'0'</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> n2 = (j &gt;= <span class="number">0</span>) ? num2[j] - <span class="string">'0'</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> temp = n1 + n2 + carry;</span><br><span class="line">            carry = temp / <span class="number">10</span>;</span><br><span class="line">            res = to_string(temp % <span class="number">10</span>) + res;</span><br><span class="line">            i--;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (carry == <span class="number">1</span>)</span><br><span class="line">            res = <span class="string">"1"</span> + res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">// @lc code=end</span></span><br></pre></td></tr></table></figure>

<h2 id="434-字符串中的单词数"><a href="#434-字符串中的单词数" class="headerlink" title="[434] 字符串中的单词数"></a>[434] 字符串中的单词数</h2><p><strong>统计字符串中的单词个数，这里的单词指的是连续的不是空格的字符。</strong></p>
<p><strong>请注意，你可以假定字符串里不包括任何不可打印的字符。</strong></p>
<blockquote>
<p>解题思路：即使用空格分隔字符串，但需要注意头尾的处理</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @lc app=leetcode.cn id=434 lang=cpp</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [434] 字符串中的单词数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc code=start</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countSegments</span><span class="params">(<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> pos = s.find_first_not_of(<span class="string">' '</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> last = s.find_first_of(<span class="string">' '</span>, pos);</span><br><span class="line">        <span class="keyword">while</span> (pos != <span class="built_in">string</span>::npos &amp;&amp; last != <span class="built_in">string</span>::npos)</span><br><span class="line">        &#123;</span><br><span class="line">            pos = s.find_first_not_of(<span class="string">' '</span>, last + <span class="number">1</span>);</span><br><span class="line">            last = s.find_first_of(<span class="string">' '</span>, pos);</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pos != <span class="built_in">string</span>::npos &amp;&amp; last == <span class="built_in">string</span>::npos)</span><br><span class="line">            count++;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">// @lc code=end</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode349-387</title>
    <url>/2020/02/27/leetcode349-387/</url>
    <content><![CDATA[<h1 id="LeetCode-探索：发散你的思维"><a href="#LeetCode-探索：发散你的思维" class="headerlink" title="LeetCode 探索：发散你的思维"></a>LeetCode 探索：发散你的思维</h1><a id="more"></a>

<h2 id="349-两个数组的交集"><a href="#349-两个数组的交集" class="headerlink" title="[349] 两个数组的交集"></a>[349] 两个数组的交集</h2><p><strong>描述：给定两个数组，编写一个函数来计算它们的交集。</strong></p>
<blockquote>
<p>解题思路：使用哈希表</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @lc app=leetcode.cn id=349 lang=cpp</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [349] 两个数组的交集</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc code=start</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">intersection</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s2;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums1.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            s1.insert(nums1[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums2.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            s2.insert(nums2[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s1.size() &lt; s2.size())</span><br><span class="line">        &#123;</span><br><span class="line">            swap(s1, s2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : s2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s1.count(n) != <span class="number">0</span>)</span><br><span class="line">                res.push_back(n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">// @lc code=end</span></span><br></pre></td></tr></table></figure>

<h2 id="350-两个数组的交集Ⅱ"><a href="#350-两个数组的交集Ⅱ" class="headerlink" title="[350] 两个数组的交集Ⅱ"></a>[350] 两个数组的交集Ⅱ</h2><p><strong>描述：给定两个数组，编写一个函数来计算它们的交集。</strong></p>
<ul>
<li>输出结果中的每个元素一定是唯一的。</li>
<li>我们可以不考虑输出结果的顺序。</li>
</ul>
<blockquote>
<p>解题思路：使用哈希表</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @lc app=leetcode.cn id=350 lang=cpp</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [350] 两个数组的交集 II</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc code=start</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">intersect</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums1.size() &gt; nums2.size())</span><br><span class="line">            swap(nums1, nums2);</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; table;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : nums1)</span><br><span class="line">        &#123;</span><br><span class="line">            table[n]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : nums2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (table[n] &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                res.push_back(n);</span><br><span class="line">                table[n]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">// @lc code=end</span></span><br></pre></td></tr></table></figure>

<h2 id="367-有效的完全平方数"><a href="#367-有效的完全平方数" class="headerlink" title="[367] 有效的完全平方数"></a>[367] 有效的完全平方数</h2><p><strong>描述：给定一个正整数 num，编写一个函数，如果 num 是一个完全平方数，则返回 True，否则返回 False。</strong></p>
<h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><blockquote>
<p>解题思路：</p>
<ul>
<li>将left设置为2，right设置为num / 2</li>
<li>当left &lt;= right时，mid = (left + right) / 2</li>
<li>比较square = mid * mid与num的大小</li>
</ul>
<ul>
<li>当square比num小时，left = mid + 1</li>
<li>当square比num大时，right = mid - 1</li>
<li>否则，返回true</li>
</ul>
<ul>
<li>当循环退出时，返回false</li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @lc app=leetcode.cn id=367 lang=cpp</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [367] 有效的完全平方数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc code=start</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPerfectSquare</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> right = num / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">long</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (mid * mid &gt; num)</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (mid * mid &lt; num)</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">// @lc code=end</span></span><br></pre></td></tr></table></figure>

<h2 id="371-两数之和"><a href="#371-两数之和" class="headerlink" title="[371] 两数之和"></a>[371] 两数之和</h2><p><strong>不使用运算符 + 和 - ​​​​​​​，计算两整数 ​​​​​​​a 、b ​​​​​​​之和。</strong></p>
<blockquote>
<p>解题思路：使用位运算和与运算</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @lc app=leetcode.cn id=371 lang=cpp</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [371] 两整数之和</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc code=start</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b == <span class="number">0</span> ? a : getSum(a ^ b, ((<span class="keyword">unsigned</span> <span class="keyword">int</span>)a &amp; b) &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">// @lc code=end</span></span><br></pre></td></tr></table></figure>

<h2 id="374-猜数字大小"><a href="#374-猜数字大小" class="headerlink" title="[374] 猜数字大小"></a>[374] 猜数字大小</h2><p><strong>我们正在玩一个猜数字游戏。 游戏规则如下：</strong><br><strong>我从 1 到 n 选择一个数字。 你需要猜我选择了哪个数字。每次你猜错了，我会告诉你这个数字是大了还是小了。你调用一个预先定义好的接口 guess(int num)，它会返回 3 个可能的结果（-1(小)，1(大) 或 0(猜对了)）</strong></p>
<blockquote>
<p>解题思路：二分查找</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @lc app=leetcode.cn id=374 lang=cpp</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [374] 猜数字大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc code=start</span></span><br><span class="line"><span class="comment">// Forward declaration of guess API.</span></span><br><span class="line"><span class="comment">// @param num, your guess</span></span><br><span class="line"><span class="comment">// @return -1 if my number is lower, 1 if my number is higher, otherwise return 0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">guess</span><span class="params">(<span class="keyword">int</span> num)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">//二分查找</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">guessNumber</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> right = n;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">long</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (guess(mid) == <span class="number">1</span>)</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (guess(mid) == <span class="number">-1</span>)</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">// @lc code=end</span></span><br></pre></td></tr></table></figure>

<h2 id="383-赎金信"><a href="#383-赎金信" class="headerlink" title="[383] 赎金信"></a>[383] 赎金信</h2><p><strong>描述：给定一个赎金信 (ransom) 字符串和一个杂志(magazine)字符串，判断第一个字符串ransom能不能由第二个字符串magazines里面的字符构成。如果可以构成，返回 true ；否则返回 false。</strong></p>
<p><strong>(题目说明：为了不暴露赎金信字迹，要从杂志上搜索各个需要的字母，组成单词来表达意思。)</strong></p>
<blockquote>
<p>解题思路：使用哈希表</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @lc app=leetcode.cn id=383 lang=cpp</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [383] 赎金信</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc code=start</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canConstruct</span><span class="params">(<span class="built_in">string</span> ransomNote, <span class="built_in">string</span> magazine)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ransomNote.length() &gt; magazine.size())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> maga[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; magazine.length(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            maga[magazine[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ransomNote.length(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!maga[ransomNote[i]]--)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">// @lc code=end</span></span><br></pre></td></tr></table></figure>

<h2 id="387-字符串中的第一个唯一字符"><a href="#387-字符串中的第一个唯一字符" class="headerlink" title="[387] 字符串中的第一个唯一字符"></a>[387] 字符串中的第一个唯一字符</h2><p><strong>给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。</strong></p>
<blockquote>
<p>解题思路：使用哈希表</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @lc app=leetcode.cn id=387 lang=cpp</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [387] 字符串中的第一个唯一字符</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc code=start</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">firstUniqChar</span><span class="params">(<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> table[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            table[s[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (table[s[i]] == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">// @lc code=end</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/02/27/hello-world/</url>
    <content><![CDATA[<p><strong>这是摘要</strong>：等我有空再写！！！</p>
<a id="more"></a>

<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=584155&auto=1&height=66"></iframe>

<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">if</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello World"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
      <tags>
        <tag>code</tag>
      </tags>
  </entry>
</search>
